== Arquivos

:online: {gitrepo}/blob/master/livro/capitulos/code/cap5
:local: code/cap5

.Objetivos do capítulo
____

Ao final deste capítulo você deverá ser capaz de:

* Entender o conceito de arquivos e seus tipos;
* Aprofundar o conhecimento sobre armazenamento e manipulação de dados
  no computador por meio do uso de arquivos;
* Fazer manipulação de dados em arquivos por meio de operações como
  leitura, escrita, dentre outras.  

____


Até agora foi visto como é possível gravar e acessar informações/dados
na memória primária/principal do computador (também chamada memória
RAM). Para isso, foi visto que o uso de ponteiros é fundamental. O
problema dessa abordagem é que as informações/dados de um programa em
C gravadas na memória RAM são perdidas após o término da execução
desse programa. Ou seja, não se pode mais acessá-las ou recuperá-las.
Como fazer para, após a execução de um programa em C, ter acesso a
dados/informações manipuladas nesse programa? Uma solução é gravar
esses dados/informações em um arquivo na memória secundária do
computador (também chamado de Disco Rígido – Hard Disk drive). Nesse
caso, após a execução do programa em C, esses dados/informações
estarão disponíveis no arquivo gravado no disco rígido da máquina.

Nesse capítulo serão abordados conceitos básicos sobre arquivos e
formas de manipulação de dados no disco rígido na linguagem C, como
por exemplo, estratégias para salvar e recuperar dados/informações em
arquivos.

=== Lingua do i

Nós vamos aprender a manipular arquivos em C através da construção de
um pequeno aplicativo que possa ler de um arquivo o texto em português
e convertê-lo para a Língua do i.

A ((*Lingua do i*)) é uma brincadeira infantil que consiste em falar ou
escrever palavras trocando todas as vogais por ``i'':

 Ela ama banana. (em português)
 Ili imi binini. (na língua do i)

=== Etapa 1: Estrutura inicial do projeto

Vamos começar montando uma estrutura inicial do nosso projeto, que
consistirá em:

* Um arquivo que conterá o `main` da aplicação
* Um arquivo _core_ e seu cabeçalho, que conterão as principais funções da aplicação
* Um arquivo para codificação dos testes
* Um arquivo para ser lido nos testes: um trecho de música 
* Um arquivo Makefile para compilação e execução dos testes
* Existirão ao total 3 arquivos fontes (`.c`). Um deles será para
  execução da aplicação e outro para execução dos testes. Estes dois
  arquivos são independentes entre si. O último arquivo, chamado de
  *core*, conterá as as implementações das funcionalidades que
  precisarão ser incluídas e ligadas nos outros dois arquivos para
  funcionarem em conjunto.

==== Código da etapa

===== Main da aplicação

:etapa: etapa1

.Código fonte
{online}/{etapa}/src/lingua-do-i.c[{local}/{etapa}/src/lingua-do-i.c]

[source, c]
.Código que contém o main do aplicativo, com implementação estúpida
----
include::{local}/{etapa}/src/lingua-do-i.c[]
----

<1> *Implementação estúpida* para o main da aplicação.
<2> Retorna `EXIT_SUCCESS` indicando que a aplicação saiu sem erros.

NOTE: `EXIT_SUCCESS` é definido em <<stdlib_h>>, junto com
`EXIT_FAILURE` que tem o propósito inverso: indicar que houve erro na
execução da aplicação.

TIP: O termo técnico *((implementação estúpida))* provém do inglês:
*dummy implementation*. Geralmente utilizado quando não desejamos
implementar apropriadamente ainda, também costuma ter o propósito de
fazer o código compilar ou apenas preencher algum trecho do código.

[IMPORTANT]
====
Este arquivo será o responsável por iniciar a aplicação, no entanto,
por enquanto ele possui uma implementação estúpida, pois não será
utilizado no momento. 

Nós vamos primeiro construir as funcionalidades do programa e os
testes para verificar que elas estão funcionando apropriadamente,
antes de integrá-las na aplicação.  

====

===== Teste das funcionalidades
:etapa: etapa1

.Código fonte
{online}/{etapa}/src/lingua-do-i-test.c[{local}/{etapa}/src/lingua-do-i-test.c]

[source, c]
.Código fonte para os testes
----
include::{local}/{etapa}/src/lingua-do-i-test.c[]
----
<1> Finaliza aplicação indicando que houve um erro.
<2> Executa `strcomp` (definida em <<string_h>>) que compara dois
    strings, retorna `0` somente se ambos os string forem iguais. A
    variável `comparacao` irá guardar o resultado da comparação.
<3> Inclui/chama uma função que desejamos criar em _core_. Ela precisa ser
    *definida no arquivo de cabeçalho de core* e *implementa no arquivo
    fonte de core*. Para ser utilizada aqui é necessário a *inclusão
    do arquivo de cabeçalho* e *ligar* arquivo do _core_ durante a
    compilação do arquivo  (ver no Makefile). Neste trecho estamos
    definindo como desejamos que função se comporte.
<4> Chama uma função de teste que tem o propósito de garantir
    que o conteúdo lido é igual ao conteúdo esperado. Caso os
    conteúdos sejam diferentes a aplicação será aborta com um erro.
    Caso contrário, podemos considerar o teste como uma comprovação de
    que a função `lerConteudoDoArquivo` está funcionando corretamente.
<5> Chamada a função que executa um teste de leitura de arquivo. Esta
    função será executada quando o programa de teste for compilado e
    invocado, pois está dentro da função `main` do arquivo de testes.

TIP: Percebam que os _nomes_ das funções descrevem o comportamento
esperado, sem a necessidade comentários: `lerConteudoDoArquivo`,
`testLerConteudoDoArquivo` e `verificaConteudosSaoIguais`.  Além
disso, as variáveis também seguem a recomendação de que as constantes
devem ser escritas em caixa alta: `NOME_DO_ARQUIVO`,
`CONTEUDO_ESPERADO` e `conteudo`. Esta é uma boa prática que você pode
utilizar em seus projetos.

Este é o principal arquivo desta etapa, onde está codificado um teste
de uma funcionalidade que desejamos implementar: leitura do conteúdo
de um arquivo.

===== Cabeçalho de Core

.Código fonte
{online}/etapa1/src/lingua-do-i-core.h[{local}/etapa1/src/lingua-do-i-core.h]

[source, c]
.Cabeçaho do Core
----
include::{local}/etapa1/src/lingua-do-i-core.h[]
----

<1> Estratégia para definição de cabeçalho que evita erros caso o
    arquivo seja incluído mais de uma vezes. Todos os arquivos de
    cabeçalho da biblioteca padrão de C utiliza esta estratégia.
<2> Definição da função que será implementada no arquivo `.c`

===== Core da aplicação

.Código fonte
{online}/etapa1/src/lingua-do-i-core.c[{local}/etapa1/src/lingua-do-i-core.c]

[source, c]
.Core do programa, onde as funções serão implementadas
----
include::{local}/etapa1/src/lingua-do-i-core.c[]
----
<1> Inclusão do arquivo de cabeçalho, onde estão definidas as funções
    públicas (visíveis ao ligar este arquivo). Por enquanto só contém
    um única função: `lerConteudoDoArquivo`.
<2> Implementação estúpida da função que desejamos implementar.

===== Arquivo texto para teste

.Código fonte
{online}/etapa1/src/musica-trecho.txt[{local}/etapa1/src/musica-trecho.txt]

.Conteúdo do arquivo que está sendo utilizado no testes
----
include::{local}/etapa1/src/musica-trecho.txt[]
----

.Execução do hexdump para verificar conteúdo do arquivo em hexadecimal
----
include::{local}/etapa1/hexdump-command.txt[]
----

O conteúdo deste arquivo contém apenas uma frase, para simplificar a
execução do teste. A ((codificação)) utilizada na escrita do arquivo
foi a UFT-8.

O programa `hexdump`, disponível no Linux, exibe o conteúdo do arquivo
em hexadecimal. Nele você poderá ver como os caracteres estão escritos
no disco:

Pela execução do `hexdump`, verificamos que o arquivo possui *0x23
bytes de tamanho* (equivale a `2x16+3=35`), indicado na última linha.

Também podemos perceber que todos os carácteres foram codificados com
1 byte cada (basta contar os carácteres). 

O arquivo não termina com o carácter de fim de linha -- ele finaliza
apenas com o carácter `o`, que tem seu código ASCII igual a `0x6f`. 

TIP: Você pode consultar a tabela ASCII em http://www.asciitable.com,
ou se estiver no Linux através do comando `man ascii`.

IMPORTANT: Ao criar um arquivo de texto para os testes, certifique-se
de conhecer o conteúdo do arquivo criado. As vezes os editores de
texto podem adicionar carácteres de fim de linha que talvez não esteja
visível para você. A execução do `hexdump` é recomendada nestes casos.

===== Makefile

.Código fonte
{online}/etapa1/src/Makefile[{local}/etapa1/src/Makefile]

.Makefile do projeto, demonstra como compilar os programas
----
include::{local}/etapa1/src/Makefile[]
----

Por fim, temos um Makefile para gerenciar a compilação e execução dos
testes.

NOTE: Este arquivo foi criado para funcionar no Linux, para funcionar
em outras plataformas serão necessários pequenos ajustes.

`CC`:: indica qual o compilador estamos utilizando. Caso utilize outro,
configure o seu compilador aqui.

`CFLAGS`:: configura algumas _flags_ de compilação. Inclusive a
utilização do padrão *c1x*. Caso seu compilador aceite estas _flags_,
não haverá necessidade de configuração.

`all`:: indica quais as regras serão executadas por padrão quando
executamos o comando `make` sem nenhum parâmetro.

`lingua-do-i` e `lingua-do-i-test`:: regras para construção dos
aplicativos.

`test_all`:: regra para execução dos testes. Consiste em invocar o
aplicativo de teste.

`clean`:: regra para apagar os arquivos construídos. A implementação
desta regra consiste em invocar o comando `rm` no Linux, que realiza a
exclusão dos arquivos passados como parâmetros.

Para compilar os aplicativos podemos executar:

  make clean && make all

Para compilar e testar os aplicativos podemos executar:

  make clean && make all && make test_all

==== Processo de implementação da etapa
Nesta seção elencamos os passos que foram necessários para
implementação do código desta etapa:

Estrutura dos arquivos com testes::
Sem dúvida o primeiro passo foi decidir que iríamos construir nosso
aplicativo utilizando testes. Para isso é necessário quebrar nosso
aplicativo em códigos fontes separados:
* um código para conter as implementações das funções da nossa
  aplicação, que estamos chamando de *core*.
* outro código para testar o funcionamento destas funções
* e outro que seja o aplicativo propriamente dito.
* para utilizar as funcionalidades de core será necessário incluir o
  cabeçalho (arquivo `.h`) antes de invocá-lo. Além disso, será
  necessário ligá-lo durante a compilação do teste ou aplicativo.

Escolhendo a primeira função que será implementada::
A próxima etapa foi escolher que função iremos implementar. Para a
implementação da língua do i, julgamos que a primeira funcionalidade
deveria ser ler o conteúdo que será traduzido.

Escrevendo o teste antes da implementação::
Antes de implementar uma função para ler o conteúdo, primeiro
escrevemos o teste que irá validar a implementação:
+
[source,c]
----
char* NOME_DO_ARQUIVO = "...";
char* CONTEUDO_ESPERADO = "...";
void testLerConteudoDoArquivo(){
  char* conteudo = lerConteudoDoArquivo(NOME_DO_ARQUIVO);
  verificaConteudosSaoIguais(conteudo, CONTEUDO_ESPERADO);
}
----
+
Neste momento as seguintes funções ainda não existiam:
`lerConteudoDoArquivo` e `verificaConteudosSaoIguais`. No entanto ao
escrevermos assim, nós já decidimos qual serão os propósitos delas e
como elas serão invocadas. 

Preparar os dados do teste::
O próximo passo foi criar um arquivo com conteúdo textual. Por enquanto
bastava apenas uma frase. Escolhi uma  música de Luiz Gonzaga, chamada
_Súplica Cearense_, e salvei apenas a primeira frase no arquivo
`musica-trecho.txt`. Em seguida atualizei o arquivo do teste:
+
[source,c]
----
char* NOME_DO_ARQUIVO = "musica-trecho.txt";
char* CONTEUDO_ESPERADO = "Oh! Deus, perdoe este pobre coitado";
----

O primeiro passo ao escrever este arquivo foi decidir o que desejamos
fazer primeiro:  

Criando implementação idiota da função::
O próximo passo foi criar o arquivo de cabeçalho de core, adicionando
o protótipo da função `lerConteudoDoArquivo`:
+
[source,c]
----
#ifndef LINGUA_DO_I_CORE_H_
#define LINGUA_DO_I_CORE_H_

char* lerConteudoDoArquivo(char* nomeDoArquivo);

#endif
----
+
Em seguida incluímos o cabeçalho no arquivo de teste e para possibilitar
invocação da função, e do core onde a função será implementada:
+
[source,c]
----
#include "lingua-do-i-core.h"
----
+
Por último criamos uma implementação estúpida da função em core:
+
[source,c]
----
char* lerConteudoDoArquivo(char* nomeDoArquivo){
  return NULL;
}
----

Atualização do Makefile::
Inclusão das regras para compilação e execução dos testes:
+
----
lingua-do-i-test: lingua-do-i-test.c
  $(CC) $(CFLAGS) lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
----

Implementação da verificação do teste::
Neste passo implementamos a função que irá validar o teste:
+
[source,c]
----
void verificaConteudosSaoIguais(char* conteudo, char* esperado){
  if(conteudo == NULL){
    exit(EXIT_FAILURE);
  }
  int comparacao = strcmp(conteudo, esperado);
  if (comparacao!=0){
    exit(EXIT_FAILURE);
  };
}
----

Execução do teste::
Para execução do teste utilizamos o seguinte comando:
+
....
include::{local}/etapa1/make-command.txt[]
....
+
Os arquivos estão compilando e o teste retorna erro, indicando que os
strings não são iguais.

Estamos no bom caminho, agora só precisamos
`lerConteudoDoArquivo` para o teste passar.

=== Etapa 2: Utilizando assert ao invés de exit

(((assert)))

Nesta etapa vamos apenas utilizar a função `assert` ao invés de
`exit(EXIT_FAILURE)`.

A função `assert`, definida em <<assert_h>>, costuma ser utilizada para
depuração dos programas. Caso a função receba uma expressão com o
valor igual a 0 (zero) causará uma falha na execução da aplicação,
indicando, através de uma mensagem, a linha do código fonte onde a
falha está ocorrendo. 

==== Código da etapa

===== Teste das funcionalidades

.Código fonte
{online}/etapa2/src/lingua-do-i-test.c[{local}/etapa2/src/lingua-do-i-test.c]

[[e_assert]]
[source, c]
.Inclusão de assert no código fonte para os testes
----
include::{local}/etapa2/src/lingua-do-i-test.c[]
----
<1> Inclusão da biblioteca `assert.h`
<2> Atualização das verificações utilizando `assert`

==== Passos de implementação da etapa

Atualização do teste::
Neste passo incluímos a biblioteca <<assert_h>> e atualizamos a função
`verificaConteudosSaoIguais` para chamar a função `assert`, incluindo
uma mensagem para descrever o erro:
+
[source,c]
----
#include <assert.h>
// (...)
void verificaConteudosSaoIguais(char* conteudo, char* esperado){
  assert(conteudo != NULL && "conteúdo não pode ser NULL");

  assert( strcmp(conteudo, esperado) == 0
          && "conteúdo deve ser igual ao esperado");
}
----

Compilação e execução do teste::
O próximo passo é compilar e executar o teste, verificando que ele
continua falhando:
+
....
include::{local}/etapa2/make-command.txt[]
....

Apesar do teste continuar falhando, agora nós temos certeza do ponto
onde está ocorrendo a falha, na linha 8 do arquivo
`lingua-do-i-test.c`, como indicado na mensagem: `lingua-do-i-test.c:8`.

=== Etapa 3: Fazendo o teste passar

Nesta etapa iremos fazer o teste passar, para garantir que nosso teste
está funcionando corretamente.

Para isso é necessário apenas que nossa função `lerConteudoDoArquivo`
retorne o valor esperado, que corresponde ao conteúdo do arquivo.

==== Código da etapa

===== Implementação para fazer o teste passar

.Código fonte
{online}/etapa3/src/lingua-do-i-core.c[{local}/etapa3/src/lingua-do-i-core.c]

[source, c]
.Core do programa, onde as funções serão implementadas
----
include::{local}/etapa3/src/lingua-do-i-core.c[]
----
<1> inclusão de variável com o valor esperado
<2> retornando o valor esperado


==== Passos de implementação da etapa

Fazendo o teste passar::
Este passo consiste em realizar as alterações necessárias para o teste
passar.

Execução do teste::
Os arquivos são compilados e verificamos a execução do teste passando:
Compilando e executando o teste::
Após as modificações vamos verificar se as funções copiadas realmente
fazem o que se propões a fazer corretamente:
+
....
include::{local}/etapa3/make-command.txt[]
....

IMPORTANT: Apesar de ser esperado que o teste passe, é importante
executá-lo e vê-lo passando, pois as vezes a verificação do teste está
implementada errada, proporcionando conclusões erradas.

=== Etapa 4: Lendo do arquivo

Nesta etapa precisamos implementar a leitura do arquivo e verificar o
teste passando.

TIP: Para verificar como as funções que manipulam arquivos em C são
invocadas para realizar tarefas comuns, recomendo acessar a página
https://gist.github.com/edusantana/8291576 onde estão reunidos
diversos testes demonstrando as funções de manipulação de arquivos.

==== Código da etapa

===== Fornecendo código para leitura de arquivo

.Código fonte
{online}/etapa4/src/lingua-do-i-core.c[{local}/etapa4/src/lingua-do-i-core.c]

[source, c]
.Atualização do code com funções para leitura de arquivo
----
include::{local}/etapa4/src/lingua-do-i-core.c[]
----
<1> Inclusão da biblioteca <<stdbool_h>>, que define o tipo `bool`. Este
    tipo pode ser utilizado como retorno de expressões lógicas. Além
    disso também estão definidos macro `true` com o valor `1` e
    `false` com o valor `0`.
<2> A função `fopen` (<<fopen>>) retorna um ponteiro para `File` se
    conseguir abrir o arquivo, caso contrário retorna `NULL`. Esta
    função tem o propósito de verificar o resultado da chamada àquela
    função.
<3> Para ler o tamanho de um arquivo é necessário ir para o final dele
    e solicitar a posição atual, que corresponde a quantidade de bytes
    que o arquivo possui. Caso o arquivo seja um fluxo (_stream_)
    talvez não seja possível ir *ao final do fluxo*.
<4> Para criar um string com o conteúdo do arquivo, primeiro
    precisamos alocar uma sequência contínua de memória que comporte o
    conteúdo que será lido. Além disso, um string deve terminar com o
    caractér `\0`, para utilização das funções de string. A função
    `calloc` (<<calloc>>), além de alocar espaço na memória,
    inicializa todo o espaço alocado com `0` (zeros). Nem sempre é
    possível alocar espaço para armazenar o espaço do arquivo inteiro,
    caso ele seja grande demais.
<5> Um arquivo para ser lido precisa ser aberto e fechado.

A implementação faz referência a diversas funções que ainda não vimos
como funciona: <<fopen>>, <<fclose>>, <<fread>> e <<fseek>>. Além
disso, os arquivos são referenciados através de um ponteiro para
`FILE` (`File *arquivo`).  

==== Passos de implementação da etapa

Implementando leitura do arquivo::
Neste passo nós copiamos as funções contidas em
https://gist.github.com/edusantana/8291576 que estão relacionadas a
leitura do conteúdo de um arquivo e atualizamos nosso arquivo core.

Compilando e executando o teste::
Após as modificações vamos verificar se as funções copiadas realmente
fazem o que se propões a fazer corretamente:
+
....
include::{local}/etapa4/make-command.txt[]
....

Nosso teste continua passando! Isto quer dizer que nossa função foi
capaz de ler o conteúdo do arquivo corretamente.

=== Etapa 5: Trocando as vogais do string por i

xx

==== Passos

Inclusão de teste de tradução::
xx.
+
Compilando para descobrir o próximo passo:
+
....
$ make clean && make lingua-do-i-test && make test_all
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
lingua-do-i-test.c: Na função ‘testTraducaoParaLinguaDoI’:
lingua-do-i-test.c:24:2: aviso: implicit declaration of function ‘traduzParaLingaDoI’ [-Wimplicit-function-declaration]
lingua-do-i-test.c:24:28: aviso: initialization makes pointer from integer without a cast [habilitado por padrão]
/tmp/ccsT5OZs.o: In function `testTraducaoParaLinguaDoI':
/home/santana/asciibook/linguagem-de-programacao-i-livro/livro/capitulos/code/cap5/etapa5/src/lingua-do-i-test.c:24: undefined reference to `traduzParaLingaDoI'
collect2: ld returned 1 exit status
make: ** [lingua-do-i-test] Erro 1
....

Criando função `traduzParaLingaDoI`::
Adição da definição no cabeçalho e implementação estúpida no arquivo
core.
+
Compilando e executando o teste para descobrir o próximo passo:
+
....
$ make clean && make lingua-do-i-test && ./lingua-do-i-test
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
lingua-do-i-test: lingua-do-i-test.c:8: verificaConteudosSaoIguais: Assertion `conteudo != ((void *)0) && "conteúdo não pode ser NULL"' failed.
Abortado (imagem do núcleo gravada)
....

==== Código da etapa

incluir código aqui.

=== Etapa 6: Fazendo o teste passar

:etapa: etapa6

==== Passos

===== Fazendo o teste passar
Alteramos a função `traduzParaLingaDoI` para retornar o valor
esperado.

.Código fonte
{online}/etapa6/src/lingua-do-i-core.c[{local}/etapa6/src/lingua-do-i-core.c]

[source,c]
----
char* TRADUCAO="Minhis vigiis, tidi iqui.";
char* traduzParaLingaDoI(char* mensagemOriginal){
	return TRADUCAO;
}
----

.Execução do teste após modificação
....
$ make clean && make lingua-do-i-test && ./lingua-do-i-test
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o
lingua-do-i-test
....

Ótimo, nosso teste está passando! 

==== Código da etapa
.Código fonte
{online}/{etapa}/src/lingua-do-i-core.c[{local}/{etapa}/src/lingua-do-i-core.c]

[source, c]
----
include::{local}/{etapa}/src/lingua-do-i-core.c[]
----

=== Etapa 7: Implementando troca das vogais

:etapa: etapa7

==== Implementando troca das vogais

Inclusão de <<string_h>>, pois vamos usar a função <<strlen>>.

Atualiza `traduzParaLingaDoI` 

[source,c]
----
char* traduzParaLingaDoI(char* mensagemOriginal){ 
	int tamanhoDaMensagem = strlen(mensagemOriginal);
	char* resposta = calloc(1, tamanhoDaMensagem+1);
	for(int i=0; i<tamanhoDaMensagem; i++){
		char caracterDaMensagemOriginal = mensagemOriginal[i];
		resposta[i] = traduzCaracterParaLinguaDoI(
				caracterDaMensagemOriginal);
	}
	return resposta;
}
----


Cria `traduzCaracterParaLinguaDoI`

[source,c]
----
char traduzCaracterParaLinguaDoI(char original){ 
	char resposta;
	switch (original) {
	case 'a':
	case 'e':
	case 'i':
	case 'o':
	case 'u':
		resposta = 'i';
		break;
	default:
		resposta = original;
	}
	return resposta;
}
----

.Apesar da nossa implementação o erro continua
....
include::{local}/{etapa}/make-command.txt[]
....

==== Código da etapa

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.c[{local}/{etapa}/src/lingua-do-i-core.c]

[source, c]
----
include::{local}/{etapa}/src/lingua-do-i-core.c[]
----
<1> Inclusão de `string.h`
<2> Criação de função para traduzir um carácter.
<3> Implementação real da função de traduzir
<4> Optamos por criar uma nova mensagem como resposta, ao invés de
    alterar a mensagem original.

[[sec_etapa8]]
=== Etapa 8: Depurando a aplicação
:etapa: etapa8

Apesar da nossa simples implementação aparentar está correta, por uma
razão ainda desconhecida o nosso teste está falhando.

Esta é uma boa oportunidade para *((Depurar))* a execução do programa.
A depuração será abordada em um capítulo a parte: <<cap_depuracao>>. O
processo de depuração permite-nos identificar sem precisar alterar o
código inserindo várias mensagens do tipo:

  printf("passou por aqui...")
  printf("O valor de var=%d",var)

TIP: Apesar de não ser um pré-requisito para continuação deste
capítulo, convidamos você a ler o <<cap_depuracao>> antes de
continuar, para conhecer o processo de depuração.

==== Passos

===== Depuração do programa
A depuração do programa pode ser vista na <<sec_depuracao>> e a
identificação do problema na <<sec_depuracao_resultado>>.

===== Correção e verificação do teste passando

Após a correção do código fonte, executamos o teste novamente:

.Re-executando o teste após a correção
....
$ make clean && make && ./lingua-do-i-test 
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i.c lingua-do-i-core.c -o lingua-do-i
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
....

Nosso teste está passando novamente!

[[sec_etapa8_codigo]]
==== Código

.Código fonte
{online}/{etapa}/src/lingua-do-i-test.c[{local}/{etapa}/src/lingua-do-i-test.c]

[source, c]
.Código fonte para os testes
----
include::{local}/{etapa}/src/lingua-do-i-test.c[]
----
<1> Correção realizada


[[sec_etapa9]]
=== Etapa 9: Inclusão de novos testes

Após a correção, nossos testes estão passando. Mas será que a
implementação de `traduzParaLingaDoI` está correta?  Vamos adicionar
novos testes para garantir isso.

==== Passos

===== Adição de testes

[source,c]
----
char* MENSAGEM_ORIGINAL2 = "Oh! Deus, será que o senhor se zangou";
char* TRADUCAO_ESPERADA2= "Ih! Diis, sirí qii i sinhir si zingii";
void testTraducaoParaLinguaDoI(){
	char* mensagemTraduzida = traduzParaLingaDoI(MENSAGEM_ORIGINAL);
	verificaConteudosSaoIguais(mensagemTraduzida, TRADUCAO_ESPERADA);
	verificaConteudosSaoIguais(traduzParaLingaDoI(MENSAGEM_ORIGINAL2), TRADUCAO_ESPERADA2);
}
----

===== Execução do teste

.Execução do teste
....
$ make clean && make && ./lingua-do-i-test 
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i.c lingua-do-i-core.c -o lingua-do-i
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
lingua-do-i-test: lingua-do-i-test.c:11: verificaConteudosSaoIguais: Assertion `strcmp(conteudo, esperado) == 0 && "conteúdo deve ser igual ao esperado"' failed.
Abortado (imagem do núcleo gravada)
....

Como a falha ocorreu devido a inclusão do novo teste, isto que dizer
que precisamos atualizar a implementação para fazer o teste passar.

===== Atualizar a implementação para fazer o teste passar

A diferença do teste adicionado é que ele adiciona uma vogal
maiúscula, e outra vogal com acento: *``Oh! Deus, será''*.

Vamos atualizar nossa implementação para possibilitar esta conversão
também:

[source,c]
....
char traduzCaracterParaLinguaDoI(char original){
	char resposta;
	switch (original) {
	case 'a':
	case 'e':
	case 'i':
	case 'o':
	case 'u':
		resposta = 'i';
		break;
	case 'A':
	case 'E':
	case 'I':
	case 'O':
	case 'U':
		resposta = 'I'; // <1>
		break;
	case 'á':
	case 'é':
	case 'í':
	case 'ó':
	case 'ú':
		resposta = 'í'; // <2>
		break;
	default:
		resposta = original;
	}
	return resposta;
}
....

<1> Inclusão de conversão de letra maiúscula.
<2> Conversão de caracteres com acentos.

===== Execução dos testes após modificação
.Execução dos testes após modificação
....
$ make clean && make && make test_all
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i.c lingua-do-i-core.c -o lingua-do-i
lingua-do-i-core.c: Na função ‘traduzCaracterParaLinguaDoI’:
lingua-do-i-core.c:64:7: aviso: constante de caractere multi-caractere [-Wmultichar]
lingua-do-i-core.c:64:2: aviso: case label value exceeds maximum value for type [habilitado por padrão]
lingua-do-i-core.c:65:7: aviso: constante de caractere multi-caractere [-Wmultichar]
lingua-do-i-core.c:65:2: aviso: case label value exceeds maximum value for type [habilitado por padrão]
lingua-do-i-core.c:66:7: aviso: constante de caractere multi-caractere [-Wmultichar]
lingua-do-i-core.c:66:2: aviso: case label value exceeds maximum value for type [habilitado por padrão]
lingua-do-i-core.c:67:7: aviso: constante de caractere multi-caractere [-Wmultichar]
lingua-do-i-core.c:67:2: aviso: case label value exceeds maximum value for type [habilitado por padrão]
lingua-do-i-core.c:68:7: aviso: constante de caractere multi-caractere [-Wmultichar]
lingua-do-i-core.c:68:2: aviso: case label value exceeds maximum value for type [habilitado por padrão]
lingua-do-i-core.c:69:14: aviso: constante de caractere multi-caractere [-Wmultichar]
lingua-do-i-core.c:69:3: aviso: overflow in implicit constant conversion [-Woverflow]
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
lingua-do-i-core.c: Na função ‘traduzCaracterParaLinguaDoI’:
lingua-do-i-core.c:64:7: aviso: constante de caractere multi-caractere [-Wmultichar]
lingua-do-i-core.c:64:2: aviso: case label value exceeds maximum value for type [habilitado por padrão]
lingua-do-i-core.c:65:7: aviso: constante de caractere multi-caractere [-Wmultichar]
lingua-do-i-core.c:65:2: aviso: case label value exceeds maximum value for type [habilitado por padrão]
lingua-do-i-core.c:66:7: aviso: constante de caractere multi-caractere [-Wmultichar]
lingua-do-i-core.c:66:2: aviso: case label value exceeds maximum value for type [habilitado por padrão]
lingua-do-i-core.c:67:7: aviso: constante de caractere multi-caractere [-Wmultichar]
lingua-do-i-core.c:67:2: aviso: case label value exceeds maximum value for type [habilitado por padrão]
lingua-do-i-core.c:68:7: aviso: constante de caractere multi-caractere [-Wmultichar]
lingua-do-i-core.c:68:2: aviso: case label value exceeds maximum value for type [habilitado por padrão]
lingua-do-i-core.c:69:14: aviso: constante de caractere multi-caractere [-Wmultichar]
lingua-do-i-core.c:69:3: aviso: overflow in implicit constant conversion [-Woverflow]
./lingua-do-i-test
lingua-do-i-test: lingua-do-i-test.c:11: verificaConteudosSaoIguais: Assertion `strcmp(conteudo, esperado) == 0 && "conteúdo deve ser igual ao esperado"' failed.
make: *** [test_all] Abortado (arquivo core criado)
....

Quando executamos o teste, verificamos que o compilador apresentou
vários avisos e o teste falhou.

=== Etapa 10: Tratando texto com acentos

:etapa: etapa10

Na etapa anterior percebemos que a utilização de acentos provocou
falha no nosso teste.

Para compreender o problema precisamos entender sobre
*((codificação))* de arquivos.

Enquanto caracteres ASCII são facilmente codificados, pois cada
carácter possui um único byte (que corresponde ao tamanho de um
`char`), outras codificações, como UTF-8, podem possuir carácteres com
tamanhos diferentes. Alem disso, pode existir mais de uma codificação
para o mesmo carácter.

Por enquanto nós iremos utilizar o ((Algorítmo do Avestruz)) para
resolução de problemas: nós iremos ignorar o problema e continuar
nossa implementação ignorando o tratamento de acentos. Depois, quando
tivermos conhecimento suficiente para tratar este problema poderemos
voltar a ele.

TIP: Você conhecer mais sobre o *Algorítmo do Avestruz* em
http://pt.wikipedia.org/wiki/Algoritmo_do_avestruz.

==== Passos

===== Desfazer teste com acentos
[source,c]
----
char* MENSAGEM_ORIGINAL2="Oh! Deus, será que o senhor se zangou";
char* TRADUCAO_ESPERADA2="Ih! Diis, sirá qii i sinhir si zingii";<1>
----
<1> Substituição do `í` por `á`. Por enquanto nosso programa não irá
    tratar acentos. 

===== Desfazer implementação de core que tratava acentos

[source,c]
----
char traduzCaracterParaLinguaDoI(char original){
	char resposta;

	switch (original) {
	case 'a':
	case 'e':
	case 'i':
	case 'o':
	case 'u':
		resposta = 'i';
		break;
	case 'A':
	case 'E':
	case 'I':
	case 'O':
	case 'U':
		resposta = 'I';
		break;
	default:
		resposta = original;
	}

	return resposta;
}
----
===== Re-execução dos testes

.Re-execução dos testes após remoção de tratamento de acentos
....
$ make clean && make && make test_all
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i.c lingua-do-i-core.c -o lingua-do-i
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o
lingua-do-i-test
./lingua-do-i-test
....

===== Criação de arquivo TODO

Criamos um arquivo entitulado `TODO.txt` que manterá registro de
atividades que gostaríamos de realizar no futuro:

.Código fonte
{online}/{etapa}/src/lingua-do-i.c[{local}/{etapa}/TODO.txt]

[source, c]
.Criação do arquivo TODO.txt
....
include::{local}/{etapa}/TODO.txt[]
....

A criação de um arquivo *TODO* possibilita comunicar para as demais
pessoas (envolvidas ou que irão se envolver no projeto) onde elas
podem contribuir para o projeto.

==== Código fonte da etapa

===== Código do teste
.Código fonte
{online}/{etapa}/src/lingua-do-i-test.c[{local}/{etapa}/src/lingua-do-i-test.c]

[source, c]
----
include::{local}/{etapa}/src/lingua-do-i-test.c[]
----

===== Código do core
.Código fonte
{online}/{etapa}/src/lingua-do-i-test.c[{local}/{etapa}/src/lingua-do-i-core.c]

[source, c]
----
include::{local}/{etapa}/src/lingua-do-i-core.c[]
----

=== Etapa 11: Salvando conteúdo em arquivo

Além de traduzir mensagens nosso programa também precisa salvar seu
conteúdo em arquivo. Nesta etapa vamos atualizar nossa implementação
para possibilitar o salvamento.

==== Passos

===== Adicionar teste de salvamento de conteúdo

Mas uma vez, antes de iniciar a implementação da nossa funcionalidade
iremos escrever um teste para ela.

[source, c]
.Adicionando teste de salvamento de arquivo em lingua-do-i-test.c
----
void verificaConteudoFoiSalvo( FILE* arquivo, 
    char* conteudo_esperado ){
  char* conteudo = lerConteudoDeArquivoArberto(arquivo); <1>
  assert( strcmp(conteudo, conteudo_esperado) == 0
    && "Conteúdo do arquivo não corresponde ao esperado");
}

FILE * criaArquivoTemporario(){
	return tmpfile();
}

char* CONTEUDO_QUALQUER = "abracadabra";
void testSalvaConteudoEmArquivo(){
  FILE * arquivoDestino = criaArquivoTemporario(); <2>
  salvaConteudo(arquivoDestino, CONTEUDO_QUALQUER); <3>
  verificaConteudoFoiSalvo(arquivoDestino, CONTEUDO_QUALQUER); <4>

  fclose(arquivoDestino); <5>
}
----
<1> A função `lerConteudoDeArquivoArberto` foi implementada em
    `lingua-do-i-core.c`, mas ainda não está visível aqui,
    precisaremos adicioná-la ao cabeçalho mais adiante.
<2> Criação de um arquivo temporário para o teste, o conteúdo do teste
    será escrito nele. Se estivéssemos utilizando um arquivo normal,
    deveríamos nos certificar de que o arquivo não existia antes, em
    decorrência de execuções anteriores. Arquivos temporários são bons
    para os testes pois quando fechados são automaticamente excluídos.
<3> Esta função será implementada no core. Percebam que escrevemos a
    função sem passar o nome do arquivo, mas um parâmetro do tipo
    `File*`. Decidimos assim, pois pretendemos salvar o conteúdo
    também na saída padrão (que é do tipo `File*`). 
<4> Função para verificar que o conteúdo escrito no arquivo
    corresponde ao conteúdo passado para a função `salvaConteudo`.
<5> Fechamento do arquivo.


===== Atualização do arquivo de cabeçalho do core
Sabemos que temos algumas alterações pendentes para serem realizadas
no arquivo de cabeçalho do core, vamos realizá-las agora:

[source,c]
.Atualização de lingua-do-i-core.h
----
void salvaConteudo(FILE* arquivoDestino, char* conteudo); <1>
char* lerConteudoDeArquivoArberto(FILE* arquivo); <2>
----
<1> Função que desejamos implementar
<2> Declaração de função já implementada em core mas que não estava
    visível externamente ao arquivo.

===== Implementação vazia para possibilitar teste falhar

Antes de compilar e executar o teste, precisamos ainda criar uma
implementação vazia de `salvaConteudo`:

[source,c]
.Implementação vazia em lingua-do-i-core.c
----
void salvaConteudo(FILE* arquivoDestino, char* conteudo){
}
----

===== Verificando o teste falhando

Com a implementação da função realizada, vamos compilar os arquivos e
executar os testes:

.Compilação e execução dos testes
....
$ make clean && make && ./lingua-do-i-test 
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i.c lingua-do-i-core.c -o lingua-do-i
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o
lingua-do-i-test
lingua-do-i-test: lingua-do-i-test.c:28: verificaConteudoFoiSalvo:
Assertion `strcmp(conteudo, conteudo_esperado) == 0 && "Conteúdo do
arquivo não corresponde ao esperado"' failed.
Abortado (imagem do núcleo gravada)
....

Como esperado, o teste falhou pois a função que deveria escrever o
conteúdo está vazia.

===== Fazendo o teste passar

Desta vez não há uma forma simples de fazer o teste passar, precisamos
realmente escrever o conteúdo no arquivo para que o teste passe.

Então implementamos a função `salvaConteudo` da seguinte forma:

[source,c]
.Implementação para escrever conteúdo no arquivo
----
void salvaConteudo(FILE* arquivoDestino, char* conteudo){
  fprintf(arquivoDestino, "%s", conteudo);
}
----

TIP: A função <<fprintf>> é similar a <<printf>>, a única diferença é
que `printf` escreve sempre na saída padrão, enquanto que `fprintf`
recebe como parâmetro qual o arquivo onde será escrito o conteúdo.

.Execução do teste
....
$ make clean && make && ./lingua-do-i-test 
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i.c lingua-do-i-core.c -o lingua-do-i
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
....

Ótimo, nossos testes estão passando novamente!

=== XXX
* Escrever uma função que seja responsável por ler o conteúdo de um
  arquivo e retornar o conteúdo lido como um string (`char *`).
* Esta função se chamará `lerConteudoDoArquivo` e terá como parâmetro
  o nome do arquivo que desejamos ler (`char* nomeDoArquivo`).
* Esta função será definida no arquivo de cabeçalho
  (`lingua-do-i-core.h`) e implementada no arquivo fonte
  (`lingua-do-i-core.c`).
* Para 


=== Exemplos e diferenças entre Arquivos e Streams

|====
| Exemplo | Tipo | Origem
| Documento do Word | Arquivo | Disco
| Música MP3 | Arquivo | Disco
| Música em rádio on-line | Stream | Placa de Rede
| Vídeo on-line | Stream | Placa de Rede
| Comandos de voz | Stream | Microfone
| Comandos de texto | Stream | Teclado
| Imagem JPG | Arquivo | Discofootnote:[Se a imagem teve origem numa
câmera, você provavelmente copiou a imagem do cartão de memória (que é
um disco).]
| Vídeo de Segurança | Stream | Webcam
|====

Em C Arquivos e Streams (fluxos) são representados da mesma forma,
possuindo uma interface única para processar os dados. No entanto,
eles possuem características diferentes:

|====
| Recurso | Arquivo | Stream/Fluxo
| Podemos ler/escrever bytes/caracteres | Sim | Sim
| Sabemos o seu tamanho antecipadamente | Sim | Não
| São finitos | Sim | Não 
| Seu tamanho pode ser maior do que a RAM do computador | Sim | Sim
| Podemos retroceder ou avançar para ler outra parte | Sim | Não
| A leitura/escrita podem ser realizadas por partes | Sim | Sim
| Origem mais comum | Disco | Dispositivos
|====

=== Pensando sobre a implementação da Língua do i

Vamos pensar um pouco no nosso programa que irá codificar um texto na
Língua do i. 

Qual será a fonte a dados que o programa irá processar?

* Teclado?
* Arquivo pre-fixado como `portugues.txt`?
* Qualquer arquivo solicitado pelo usuário?

[NOTE]
====
A leitura através do *teclado* geralmente consiste em escrever uma
mensagem na tela solicitando o usuário digitar o texto e em seguida
ler o que foi digitado e processar. 

* Digitar um texto grande pode ser tedioso. 
* Como interajo com o programa para informar que ele deve ser finalizado?
  Quando eu digitar a palavra 'Sair' numa linha vazia? Quando não
  digitar nada numa linha vazia?

A leitura através de um *arquivo pré-fixado* pode ser mais simples de
ser implementado, pois provavelmente não há tratamento de configuração
para descobrir qual o arquivo. No entanto, é chato ter sempre que
atualizar um arquivo único para funcionar.

A leitura de qualquer arquivo pode facilitar caso o usuário possua
vários arquivos com conteúdos longos que precisam ser traduzidos.
Provavelmente iremos precisar tratar qual o arquivo será utilizado no
processamento.
====

Como a entrada será processada?

* Ler o conteúdo inteiro e depois processa?
* Ler uma linha por vês e processa?
* Ler um carácter por vez e processa?

[NOTE]
====
Ler o conteúdo inteiro geralmente parece ser a opção mais fácil quando
estamos processando arquivos. No entanto, esta solução pode
inviabilizar o processamento quando a entrada for um fluxo sem fim, ou
até mesmo quando o conteúdo for maior do que a memória do computador.

Ler uma linha por vez pode ser uma solução fácil de implementar, pois
os arquivos de texto são naturalmente divididos em linhas.

Como a tradução para a Língua do i pode ser realizada um carácter por
vez, ela solução também parece viável.
====

Aonde o resultado será apresentado?

* Na tela?
* Em um arquivo fixo como `texto-na-lingua-do-i.txt`?
* Em qualquer arquivo configurado pelo usuário?

[NOTE]
====
A apresentação na tela pode ser uma solução viável caso os conteúdos
a serem traduzidos sejam possuam poucas linhas, caso contrário é
melhor salvar o resultado num arquivo.

Salvar o resultado em um arquivo fixo geralmente não é uma boa
solução, pois não poderíamos processar dois arquivos ao mesmo tempo,
correndo o risco do resultado de um processamento ser sobrescrito pelo
outro.
====

Aonde as mensagens de erros serão apresentadas?

* Na tela?
* Em um arquivo fixo como `erros.txt`?


[NOTE]
====
A primeira vista apresentar os erros na tela parece ser uma boa
solução, no entanto, caso o seu programa esteja rodando em um serviço
num servidor as vezes é mais fácil acessar um arquivo contendo os
erros, pois a ``tela'' do processo talvez esteja indisponível.
====

=== Entrada padrão, saída padrão e saída de erros

Todo programa em C possui automaticamente definido um arquivo para a
entrada padrão, um arquivo para a saída padrão e outro arquivo para
onde a emissão de mensages de erro será direcionada.

Quando vamos executar um programa podemos redirecionar a entrada e as
saídas para outros lugares, no entanto, se não houve nenhuma
configuração o sistema operacional irá configurá-las da seguinte
forma:

.Configuração padrão para as saídas e entradas
|====
| Entrada Padrão | Teclado
| Saída Padrão | Tela
| Saída de Erros | Tela
|====

(((Redirecionar, Entrada Padrão)))

Para redirecinar a Entrada Padrão para um arquivo qualquer basta
executar o programa informando o nome do arquivo da seguinte forma:

 meu-programa < nome-do-arquivo-de-entrada

Para testar a mudança da entrada padrão recomendo a utilização do
aplicativo `sort` (disponível no Linux, OSx e Windows), que realiza
ordenação a partir da entrada padrão.

.caminho do arquivo frutas
....
include::code/cap5/frutas.txt[]
....

 sort < frutas.txt

.Resultado da execução do comando
....
include::code/cap5/frutas-ordenadas.txt[]
....

Além de redirecionar a entrada, nós também podemos redirecionar a
saída para um arquivo da seguinte forma:

 sort < frutas.txt > frutas-ordenadas.txt

Desta forma, o arquivo `frutas-ordenadas.txt` será criado
contendo o mesmo resultado da execução anterior. 

Para demonstrar o redirecionamento da saída de erro vamos utilizar o
comando `mkdir` para tentar criar um diretório que já existe.

 mkdir meudir
 mkdir meudir
 mkdir meudir 2> erros.txt

Na primeira invocação do mkdir o diretório `meu-dir` será criado. Na
segunda invocação, você verá na tela a mensagem de erro relativo a
impossibilidade de criar um diretório que já existe. Na última
execução, as mensagens de erros serão redirecionadas para um arquivo
`erros.txt` que será criado após a execução.

IMPORTANT: Quando os programas vão escrever mensagens devem escolher
cuidadosamente quais as saídas utilizar.

TIP: Para conhecer um pouco mais sobre redirecionamentos consulte:
http://edusantana.github.io/dev/redirecionamentos.html.

=== Decisões sobre a implementação: entrada e saída 

O nosso aplicativo irá *ler o texto da entrada padrão e escrever a
mensagem traduzida na saída padrão*. Caso o usuário deseja traduzir um
arquivo bastará executar a aplicação passando o arquivo pela entrada
padrão. De forma similar, também podemos redirecionar o resultado para
um arquivo se desejar-mos.

.Questões em aberto
* Como a entrada será processada?
** Ler o conteúdo inteiro e depois processa?
** Ler uma linha por vês e processa?
** Ler um carácter por vez e processa?

Para aprender todas as formas de processar a entrada vamos implementar
todas as opções.

=== Lendo o conteúdo inteiro
Ler o conteúdo inteiro antes de processar poderá causa erro de
execução caso o arquivo de entrada seja grande demais.

Durante a implementação precisaremos consultar o tamanho total do
arquivo para poder alocar espaço suficiente para o arquivo. Em
seguida, iremos criar um string contendo todos os caracteres do texto.

Com o string em memória, poderemos processar os caracteres na ordem
que aparecem e trocar as vogais por `i`, imprimindo juntamente os
caracteres restantes que não forem vogais no saída padrão.

=== Lendo uma linha por vez
Para ler uma linha por vez precisamos alocar um espaço suficiente para
salvar uma linha, em seguida preenchê-lo com os caracteres lidos até
encontrar o carácter final de linha, representado por `\n`.

NOTE: Não há problemas em alocar espaço maior do que for utilizado,
contanto que o espaço restante seja inicializado com `\0`, pois a
primeira ocorrência indicará o final de um string, o restante será
ignorado.

=== Lendo um carácter por vez
Ler um carácter por vez não envolve necessidade de alocar espaço na
memória para leitura dos dados.

NOTE: Talvez teremos problemas com codificação do arquivo. Pois
caracteres especiais ocupam mais de um byte quando codificados em
*UTF-8* por exemplo. 


////
Terminando arquivo com linha em branco
////

