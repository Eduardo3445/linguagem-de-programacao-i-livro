== Arquivos

:online: {gitrepo}/blob/master/livro/capitulos/code/cap5
:local: code/cap5

.Objetivos do capítulo
____

Ao final deste capítulo você deverá ser capaz de:

* Entender o conceito de arquivos e seus tipos;
* Aprofundar o conhecimento sobre armazenamento e manipulação de dados
  no computador por meio do uso de arquivos;
* Fazer manipulação de dados em arquivos por meio de operações como
  leitura, escrita, dentre outras.  

____


Até agora foi visto como é possível gravar e acessar informações/dados
na memória primária/principal do computador (também chamada memória
RAM). Para isso, foi visto que o uso de ponteiros é fundamental. O
problema dessa abordagem é que as informações/dados de um programa em
C gravadas na memória RAM são perdidas após o término da execução
desse programa. Ou seja, não se pode mais acessá-las ou recuperá-las.
Como fazer para, após a execução de um programa em C, ter acesso a
dados/informações manipuladas nesse programa? Uma solução é gravar
esses dados/informações em um arquivo na memória secundária do
computador (também chamado de Disco Rígido – Hard Disk drive). Nesse
caso, após a execução do programa em C, esses dados/informações
estarão disponíveis no arquivo gravado no disco rígido da máquina.

Nesse capítulo serão abordados conceitos básicos sobre arquivos e
formas de manipulação de dados no disco rígido na linguagem C, como
por exemplo, estratégias para salvar e recuperar dados/informações em
arquivos.

=== Lingua do i

Nós vamos aprender a manipular arquivos em C através da construção de
um pequeno aplicativo que possa ler de um arquivo o texto em português
e convertê-lo para a Língua do i.

A ((*Lingua do i*)) é uma brincadeira infantil que consiste em falar ou
escrever palavras trocando todas as vogais por ``i'':

 Ela ama banana. (em português)
 Ili imi binini. (na língua do i)

=== Etapa 1: Estrutura inicial do projeto

:etapa: etapa1

Vamos começar montando uma estrutura inicial do nosso projeto, que
consistirá em:

.Lista de arquivos do projeto
`lingua-do-i.c`:: Conterá o `main` da aplicação.

`lingua-do-i-core.c`:: Conterá as implementações das principais
funções da aplicação, frequentemente este arquivo será referenciado
apenas como o _core_.  

`lingua-do-i-core.h`:: Conterá as definições das funções de core.

`lingua-do-i-test.c`:: Conterá os testes da aplicação.

`musica-trecho.txt`:: Trecho de música que será utilizado no teste de
leitura de arquivo.  

`Makefile`:: Makefile para compilar o projeto e
executar os testes.

==== Criando um main estúpido

Embora não iremos nos preocupar com o main da aplicação ainda, nosso
primeiro passo será criar o main da aplicação `lingua-do-i` apenas
registrar didaticamente o propósito que este arquivo terá.

.Código fonte
{online}/{etapa}/src/lingua-do-i.c[{local}/{etapa}/src/lingua-do-i.c]

[source, c]
.Código que contém o main do aplicativo, com implementação estúpida
----
include::{local}/{etapa}/src/lingua-do-i.c[]
----

<1> *Implementação estúpida* para o main da aplicação.
<2> Retorna `EXIT_SUCCESS` indicando que a aplicação saiu sem erros.

NOTE: `EXIT_SUCCESS` é definido em <<stdlib_h>>, junto com
`EXIT_FAILURE` que tem o propósito inverso: indicar que houve erro na
execução da aplicação.

TIP: O termo técnico *((implementação estúpida))* provém do inglês:
*dummy implementation*. Geralmente utilizado quando desejamor aguardar
o momento oportuno para realizar a implementação apropriada, também
costuma ter o propósito de fazer o código compilar ou apenas preencher
algum trecho do código.

[IMPORTANT]
====
Este arquivo será o responsável por iniciar a aplicação, no entanto,
por enquanto ele possui uma implementação estúpida, será relegado até
se tornar importante novamente.

====

Nas próximas seções daremos mais atenção aos testes, enquanto iremos
implementar, aos poucos, as funcionalidades que o aplicativo terá.

Por último, iremos integrar as funcionalides implementadas ao
aplicativo em `main`.

==== Iniciando um teste

Neste passo nós iremos iniciar a implementação dos testes.  Decidimos
começar os nossos testes tentando ler o conteúdo de um arquivo:

[source,c]
.Elaborando o primeiro teste no arquivo lingua-do-i-test.c
----
#include "lingua-do-i-core.h"

char* NOME_DO_ARQUIVO = "musica-trecho.txt";
char* CONTEUDO_ESPERADO = "Oh! Deus, perdoe este pobre coitado";
void testLerConteudoDoArquivo(){
	char* conteudo = lerConteudoDoArquivo(NOME_DO_ARQUIVO);
	verificaConteudosSaoIguais(conteudo, CONTEUDO_ESPERADO);
}
----

Você é capaz de identificar a ideia da implementação deste teste?
Pense um pouco!

.Pontos a serem observados
. O primeiro ponto a ser observado é o nome da função:
  `testLerConteudoDoArquivo`. O nome de uma função deve ser suficiente
  para descrever qual é o seu propósito. 
. Em seguida, vemos a chamada da função `lerConteudoDoArquivo`, que
  ainda não existe, mas estamos planejando sua implementação. 
  +
  Durante a elaboração dos testes nós escrevemos funções supondo a sua
  existência, mas tarde implementaremos elas, somente se demonstrarem
  necessárias. 
  +
  Outro ponto importante, é que estamos definindo qual será interface
  da função: (a) ela terá somente um parâmetro que será o nome do
  arquivo que será lido; (b) ela irá retornar um ponteiro (`char*`)
  que conterá o conteúdo lido no arquivo.
. O último comando irá chamar a função `verificaConteudosSaoIguais`,
  que também não foi implementada, mas comunica qual será seu
  propósito: verificar que o conteúdo retornado pela função
  `lerConteudoDoArquivo` corresponde ao conteúdo do arquivo.
. A constante `NOME_DO_ARQUIVO` corresponde ao nome de um
  arquivofootnote:[O arquivo deve existir no mesmo diretório do
  executável] que supostamente possui o mesmo conteúdo da variável
  `CONTEUDO_ESPERADO`. Embora as constantes poderiam ser declaradas
  dentro das funções, a declaração externa possibilita uma maior
  legibilidade no código do teste, mas não há certo ou errado aqui,
  apenas estilo.
. Um ponto que talvez passe despercebido é a inclusão do arquivo de
  cabeçalho `lingua-do-i-core.h`. Ao fazermos isso, estamos
  antecipando uma dependência que nosso teste terá com
  `lingua-do-i-core.c`. Estamos planejando implementar a função
  `lerConteudoDoArquivo` neste arquivo. Durante o processo de
  compilação dos testes precisaremos ligar (_linkar_) o arquivo de
  teste com este código fonte. O Makefile do projeto deverá refletir
  esta ligação.


==== Elaborando o Makefile

Estamos planejando a elaboração de uma aplicação e um teste, portanto
nosso Makefile ficou da seguinte forma:

.Código fonte
{online}/{etapa}/src/Makefile[{local}/{etapa}/src/Makefile]

.Makefile do projeto, demonstra como compilar os programas
----
include::{local}/{etapa}/src/Makefile[]
----

NOTE: Este arquivo foi criado para funcionar no Linux, para funcionar
em outras plataformas serão necessários pequenos ajustes.

`CC`:: indica qual o compilador estamos utilizando. Caso utilize outro,
configure o seu compilador aqui.

`CFLAGS`:: configura algumas _flags_ de compilação. Inclusive a
utilização do padrão <<c1x>>. Caso seu compilador aceite estas _flags_,
não haverá necessidade de configuração.

`all`:: indica quais as regras serão executadas por padrão quando
executamos o comando `make` sem nenhum parâmetro.

`lingua-do-i` e `lingua-do-i-test`:: regras para construção dos
aplicativos.

`test_all`:: regra para execução dos testes. Consiste em invocar o
aplicativo de teste.

`clean`:: regra para apagar os arquivos construídos. A implementação
desta regra consiste em invocar o comando `rm` no Linux, que realiza a
exclusão dos arquivos passados como parâmetros.

Para compilar os aplicativos podemos executar:

  make clean && make all

Para compilar e testar os aplicativos podemos executar:

  make clean && make all && make test_all

==== Criando um main e compilando o teste

Vamos adicionar um `main` ao nosso arquivo de teste e chamar a função
`testLerConteudoDoArquivo` a partir dele:

[source,c]
----
#include <stdlib.h>
#include "lingua-do-i-core.h"

char* NOME_DO_ARQUIVO = "musica-trecho.txt";
char* CONTEUDO_ESPERADO = "Oh! Deus, perdoe este pobre coitado";
void testLerConteudoDoArquivo(){
	char* conteudo = lerConteudoDoArquivo(NOME_DO_ARQUIVO);
	verificaConteudosSaoIguais(conteudo, CONTEUDO_ESPERADO);
}

int main(void) {
	testLerConteudoDoArquivo();

	return EXIT_SUCCESS;
}
----


Nós temos algumas funções que ainda não foram escritas, mas vamos
tentar compilar o código mesmo assim, para verificar os erros que
serão aprensentados pelo compilador:

.Execução do comando para compilação
....

$ make clean && make lingua-do-i-test
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
lingua-do-i-test.c: Na função ‘testLerConteudoDoArquivo’:
lingua-do-i-test.c:7:2: aviso: implicit declaration of function ‘lerConteudoDoArquivo’ [-Wimplicit-function-declaration]
lingua-do-i-test.c:7:19: aviso: initialization makes pointer from integer without a cast [habilitado por padrão]
lingua-do-i-test.c:8:2: aviso: implicit declaration of function ‘verificaConteudosSaoIguais’ [-Wimplicit-function-declaration]
/tmp/ccEcEbRI.o: In function `testLerConteudoDoArquivo':
/home/santana/asciibook/linguagem-de-programacao-i-livro/livro/capitulos/code/cap5/etapa1/src/lingua-do-i-test.c:7:
undefined reference to `lerConteudoDoArquivo' <1>
/home/santana/asciibook/linguagem-de-programacao-i-livro/livro/capitulos/code/cap5/etapa1/src/lingua-do-i-test.c:8:
undefined reference to `verificaConteudosSaoIguais' <1>
collect2: ld returned 1 exit status
make: ** [lingua-do-i-test] Erro 1
....
<1> Mensagem informando que não foram encontradas referências às
    funções `lerConteudoDoArquivo` e `verificaConteudosSaoIguais`.

Como esperado, ocorreu erro no processo de compilação devido a
utilização de funções que não foram implementadas ainda.


==== Implementando a função verificaConteudosSaoIguais

Nosso próximo passo será a implementação da função que verifica se o
teste irá falha ou não:

[source,c]
----
#include <string.h> <1>

...

void verificaConteudosSaoIguais(char* conteudo, char* esperado){
	if(conteudo == NULL){
		exit(EXIT_FAILURE); // não pode ser NULL <2>
	}
	int comparacao = strcmp(conteudo, esperado); // <3>
	if (comparacao!=0){
		exit(EXIT_FAILURE); // strings tem que ser iguais <2>
	};
}
----
<1> Inclusão de `string.h`, que possui várias funções de manipulação
    de strings, inclusive comparação.
<2> Finaliza aplicação indicando que houve um erro.
<3> Executa `strcomp` (definida em <<string_h>>) que compara dois
    strings, retorna `0` somente se ambos os string forem iguais. A
    variável `comparacao` irá guardar o resultado da comparação.

Com a implementação desta função esperamos que o teste falhe caso 
`conteudo` for diferente de `esperado`.

Vamos compilar novamente para verificar os erros.

.Compilação após implementação da função verificaConteudosSaoIguais
....
$ make clean && make lingua-do-i-test
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o
lingua-do-i-test
lingua-do-i-test.c: Na função ‘testLerConteudoDoArquivo’:
lingua-do-i-test.c:18:2: aviso: implicit declaration of function
‘lerConteudoDoArquivo’ [-Wimplicit-function-declaration]
lingua-do-i-test.c:18:19: aviso: initialization makes pointer from
integer without a cast [habilitado por padrão]
/tmp/ccqV7RJy.o: In function `testLerConteudoDoArquivo':
/home/santana/asciibook/linguagem-de-programacao-i-livro/livro/capitulos/code/cap5/etapa1/src/lingua-do-i-test.c:18:
undefined reference to `lerConteudoDoArquivo'
collect2: ld returned 1 exit status
make: ** [lingua-do-i-test] Erro 1
....

Ótimo, agora só estamos com um erro, devido a ausência da
implementação de `lerConteudoDoArquivo`.

==== Implementando estúpida de lerConteudoDoArquivo

Vamos adicionar uma implementação estúpida de `lerConteudoDoArquivo`
somente para conseguir compilar o código.

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.c[{local}/{etapa}/src/lingua-do-i-core.c]

[source, c]
.Core do programa, onde as funções serão implementadas
----
include::{local}/{etapa}/src/lingua-do-i-core.c[]
----
<1> Inclusão do arquivo de cabeçalho, onde estarão definidas as funções
    públicas (visíveis ao ligar este arquivo). 
<2> Implementação estúpida da função que desejamos implementar.

Com esta função implementada, vamos tentar compilar novamente:

.Compilação após implementação da função que faltava
....
$ make clean && make lingua-do-i-test
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
lingua-do-i-test.c: Na função ‘testLerConteudoDoArquivo’:
lingua-do-i-test.c:18:2: aviso: implicit declaration of function ‘lerConteudoDoArquivo’ [-Wimplicit-function-declaration]
lingua-do-i-test.c:18:19: aviso: initialization makes pointer from integer without a cast [habilitado por padrão]
....

Algo estranho aconteceu, apesar de realizar a implementação da última
função que estava faltando. O compilador continua indicando que não
encontrou a função! Por que será?

==== Implementando o cabeçalho de core
Percebemos que ao compilar o arquivo de teste, não foi possível
encontrar a função `lerConteudoDoArquivo` que estava implementada no
arquivo `lingua-do-i-core.c`.

Isto costuma ocorrer pelas seguintes razões:

- A função não existe
- A função existe mas não está visível no processo de compilação
  devido a ligação ou falta de inclusão do arquivo de cabeçalho,
  indicando as definições das funções.

No nosso caso, faltou implementar o arquivo de cabeçalho, que já
estava sendo incluído em ambos os arquivos:

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.h[{local}/{etapa}/src/lingua-do-i-core.h]

[source, c]
.Cabeçaho do Core
----
include::{local}/{etapa}/src/lingua-do-i-core.h[]
----

<1> Estratégia para definição de cabeçalho que evita erros caso o
    arquivo seja incluído mais de uma vezes. Todos os arquivos de
    cabeçalho da biblioteca padrão de C utiliza esta estratégia.
<2> Definição da função que foi implementada no arquivo `.c`

Vamos compilar novamente!


.Compilando após implementação do cabeçalho
....
$ make clean && make lingua-do-i-test
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
....

Ótimo! O arquivo agora está compilando. 

==== Arquivo texto para o teste

Antes de executar o teste, ainda é preciso criar o arquivo de texto
contendo o conteúdo de `CONTEUDO_ESPERADO`. Escolhi uma música de Luiz
Gonzaga, chamada _Súplica Cearense_, e salvei apenas a primeira frase
no arquivo `musica-trecho.txt`.

.Código fonte
{online}/{etapa}/src/musica-trecho.txt[{local}/{etapa}/src/musica-trecho.txt]

.Conteúdo do arquivo que está sendo utilizado no testes
----
include::{local}/{etapa}/src/musica-trecho.txt[]
----

O conteúdo deste arquivo contém apenas uma frase, para simplificar a
execução do teste. A ((codificação)) utilizada na escrita do arquivo
foi a UFT-8.

O programa `hexdump`, disponível no Linux, exibe o conteúdo do arquivo
em hexadecimal. Nele você poderá ver como os caracteres estão escritos
no disco:

.Execução do hexdump para verificar conteúdo do arquivo em hexadecimal
----
include::{local}/{etapa}/hexdump-command.txt[]
----

Pela execução do `hexdump`, verificamos que o arquivo possui *0x23
bytes de tamanho* (equivale a `2x16+3=35`), indicado na última linha.

Também podemos perceber que todos os carácteres foram codificados com
1 byte cada (basta contar os carácteres). 

O arquivo não termina com o carácter de fim de linha -- ele finaliza
apenas com o carácter `o`, que tem seu código ASCII igual a `0x6f`. 

TIP: Você pode consultar a tabela ASCII em http://www.asciitable.com,
ou se estiver no Linux através do comando `man ascii`.

IMPORTANT: Ao criar um arquivo de texto para os testes, certifique-se
de conhecer o conteúdo do arquivo criado. As vezes os editores de
texto podem adicionar carácteres de fim de linha que talvez não esteja
visível para você. A execução do `hexdump` é recomendada nestes casos.

==== Verificando o teste falhar

O nosso código já está compilando, agora vamos executar o teste e
verificar o resultado:

.Execução do teste
....
$ make clean && make lingua-do-i-test && make test_all
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
./lingua-do-i-test
make: ** [test_all] Erro 1
....

Como esperado, nosso teste está falhando. Lembra que nossa função
`lerConteudoDoArquivo` possui uma implementação estúpida? Não há como
passar com uma implementação daquela.

Apesar do erro esperado, a mensagem de erro do teste não foi muito
amigável, indicando apenas que houve `Erro 1`. Vamos corrigir isto na
próxima etapa.

==== Código da etapa

Você pode consultar o código final desta etapa nos seguintes
arquivos:

.Código fonte
{online}/{etapa}/src/lingua-do-i.c[{local}/{etapa}/src/lingua-do-i.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-test.c[{local}/{etapa}/src/lingua-do-i-test.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.c[{local}/{etapa}/src/lingua-do-i-core.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.h[{local}/{etapa}/src/lingua-do-i-core.h]

.Código fonte
{online}/{etapa}/src/musica-trecho.txt[{local}/{etapa}/src/musica-trecho.txt]

.Código fonte
{online}/{etapa}/src/Makefile[{local}/{etapa}/src/Makefile]

Certifique-se de ter compreendido esta etapa antes de prosseguir para
a próxima.

=== Etapa 2: Utilizando assert ao invés de exit

:etapa: etapa2

(((assert)))

Na final da etapa anterior vimos que nosso teste não apresentava um
mensagem de erro amigável, informando qual a razão da falha.  Nesta
etapa vamos apenas utilizar a função `assert` ao invés de
`exit(EXIT_FAILURE)`, para mudar isso.

A função `assert`, definida em <<assert_h>>, costuma ser utilizada para
depuração dos programas. Caso a função receba uma expressão com o
valor igual a 0 (mero) causará uma falha na execução da aplicação,
indicando, através de uma mensagem, a linha do código fonte onde a
falha está ocorrendo. 

[[exemplo_assert]]
==== Utilizando assert no teste 
Neste passo incluímos a biblioteca <<assert_h>> e atualizamos a função
`verificaConteudosSaoIguais` para chamar a função `assert`, incluindo
uma mensagem para descrever o erro:

[source,c]
----
#include <assert.h> <1>
// (...)
void verificaConteudosSaoIguais(char* conteudo, char* esperado){
assert(conteudo != NULL && "conteúdo não pode ser NULL"); <2>

assert( strcmp(conteudo, esperado) == 0 <2>
        && "conteúdo deve ser igual ao esperado");
}
----
<1> Inclusão da biblioteca `assert.h`
<2> Atualização das verificações utilizando `assert`

==== Compilação e execução do teste
Vamos compilar e executar o teste, verificando que ele
continuará falhando:
+
....
$ make clean && make && make test_all
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i.c lingua-do-i-core.c -o lingua-do-i
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
./lingua-do-i-test
lingua-do-i-test: lingua-do-i-test.c:7: verificaConteudosSaoIguais: Assertion `conteudo != ((void *)0) && "conteúdo não pode ser NULL"' failed.
make: *** [test_all] Abortado (arquivo core criado)
....

Apesar do teste continuar falhando, agora nós temos certeza do ponto
onde está ocorrendo a falha, sabemos exatamente o arquivo e a linha,
como indicado na mensagem: `lingua-do-i-test.c:7`.

Maravilha! Agora estamos recebendo mensagens mais informativas.

==== Código da etapa

Você pode consultar o código final desta etapa nos seguintes
arquivos:

.Código fonte
{online}/{etapa}/src/lingua-do-i.c[{local}/{etapa}/src/lingua-do-i.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-test.c[{local}/{etapa}/src/lingua-do-i-test.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.c[{local}/{etapa}/src/lingua-do-i-core.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.h[{local}/{etapa}/src/lingua-do-i-core.h]

.Código fonte
{online}/{etapa}/src/musica-trecho.txt[{local}/{etapa}/src/musica-trecho.txt]

.Código fonte
{online}/{etapa}/src/Makefile[{local}/{etapa}/src/Makefile]


=== Etapa 3: Fazendo o teste passar
:etapa: etapa3

Nesta etapa iremos fazer o teste passar, para garantir que nosso teste
está funcionando corretamente.

Para isso é necessário apenas que nossa função `lerConteudoDoArquivo`
retorne o valor esperado, que corresponde ao conteúdo do arquivo.

==== Implementação para fazer o teste passar

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.c[{local}/{etapa}/src/lingua-do-i-core.c]

[source, c]
.Core do programa, onde as funções serão implementadas
----
include::{local}/{etapa}/src/lingua-do-i-core.c[]
----
<1> inclusão de variável com o valor esperado
<2> retornando o valor esperado


==== Passos de implementação da etapa

Fazendo o teste passar::
Este passo consiste em realizar as alterações necessárias para o teste
passar.

Execução do teste::
Os arquivos são compilados e verificamos a execução do teste passando:
Compilando e executando o teste::
Após as modificações vamos verificar se as funções copiadas realmente
fazem o que se propões a fazer corretamente:
+
....
include::{local}/{etapa}/make-command.txt[]
....

IMPORTANT: Apesar de ser esperado que o teste passe, é importante
executá-lo e vê-lo passando, pois as vezes a verificação do teste está
implementada errada, proporcionando conclusões erradas.

==== Código da etapa

Você pode consultar o código final desta etapa nos seguintes
arquivos:

.Código fonte
{online}/{etapa}/src/lingua-do-i.c[{local}/{etapa}/src/lingua-do-i.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-test.c[{local}/{etapa}/src/lingua-do-i-test.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.c[{local}/{etapa}/src/lingua-do-i-core.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.h[{local}/{etapa}/src/lingua-do-i-core.h]

.Código fonte
{online}/{etapa}/src/musica-trecho.txt[{local}/{etapa}/src/musica-trecho.txt]

.Código fonte
{online}/{etapa}/src/Makefile[{local}/{etapa}/src/Makefile]



=== Etapa 4: Lendo do arquivo
:etapa: etapa4

Nesta etapa precisamos implementar a leitura do arquivo e verificar o
teste passando.

TIP: Para verificar como as funções que manipulam arquivos em C são
invocadas para realizar tarefas comuns, recomendo acessar a página
https://gist.github.com/edusantana/8291576 onde estão reunidos
diversos testes demonstrando as funções de manipulação de arquivos.

==== Fornecendo código para leitura de arquivo

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.c[{local}/{etapa}/src/lingua-do-i-core.c]

[source, c]
.Atualização do code com funções para leitura de arquivo
----
include::{local}/{etapa}/src/lingua-do-i-core.c[]
----
<1> Inclusão da biblioteca <<stdbool_h>>, que define o tipo `bool`. Este
    tipo pode ser utilizado como retorno de expressões lógicas. Além
    disso também estão definidos macro `true` com o valor `1` e
    `false` com o valor `0`.
<2> A função `fopen` (<<fopen>>) retorna um ponteiro para `File` se
    conseguir abrir o arquivo, caso contrário retorna `NULL`. Esta
    função tem o propósito de verificar o resultado da chamada àquela
    função.
<3> Para ler o tamanho de um arquivo é necessário ir para o final dele
    e solicitar a posição atual, que corresponde a quantidade de bytes
    que o arquivo possui. Caso o arquivo seja um fluxo (_stream_)
    talvez não seja possível ir *ao final do fluxo*.
<4> Para criar um string com o conteúdo do arquivo, primeiro
    precisamos alocar uma sequência contínua de memória que comporte o
    conteúdo que será lido. Além disso, um string deve terminar com o
    caractér `\0`, para utilização das funções de string. A função
    `calloc` (<<calloc>>), além de alocar espaço na memória,
    inicializa todo o espaço alocado com `0` (zeros). Nem sempre é
    possível alocar espaço para armazenar o espaço do arquivo inteiro,
    caso ele seja grande demais.
<5> Um arquivo para ser lido precisa ser aberto e fechado.

A implementação faz referência a diversas funções que ainda não vimos
como funciona: <<fopen>>, <<fclose>>, <<fread>> e <<fseek>>. Além
disso, os arquivos são referenciados através de um ponteiro para
`FILE` (`File *arquivo`).  

==== Passos de implementação da etapa

Implementando leitura do arquivo::
Neste passo nós copiamos as funções contidas em
https://gist.github.com/edusantana/8291576 que estão relacionadas a
leitura do conteúdo de um arquivo e atualizamos nosso arquivo core.

Compilando e executando o teste::
Após as modificações vamos verificar se as funções copiadas realmente
fazem o que se propões a fazer corretamente:
+
....
include::{local}/{etapa}/make-command.txt[]
....

Nosso teste continua passando! Isto quer dizer que nossa função foi
capaz de ler o conteúdo do arquivo corretamente.

==== Código da etapa

Você pode consultar o código final desta etapa nos seguintes
arquivos:

.Código fonte
{online}/{etapa}/src/lingua-do-i.c[{local}/{etapa}/src/lingua-do-i.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-test.c[{local}/{etapa}/src/lingua-do-i-test.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.c[{local}/{etapa}/src/lingua-do-i-core.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.h[{local}/{etapa}/src/lingua-do-i-core.h]

.Código fonte
{online}/{etapa}/src/musica-trecho.txt[{local}/{etapa}/src/musica-trecho.txt]

.Código fonte
{online}/{etapa}/src/Makefile[{local}/{etapa}/src/Makefile]


=== Etapa 5: Trocando as vogais do string por i

:etapa: etapa5

Inclusão de teste de tradução::
xx.
+
Compilando para descobrir o próximo passo:
+
....
$ make clean && make lingua-do-i-test && make test_all
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
lingua-do-i-test.c: Na função ‘testTraducaoParaLinguaDoI’:
lingua-do-i-test.c:24:2: aviso: implicit declaration of function ‘traduzParaLingaDoI’ [-Wimplicit-function-declaration]
lingua-do-i-test.c:24:28: aviso: initialization makes pointer from integer without a cast [habilitado por padrão]
/tmp/ccsT5OZs.o: In function `testTraducaoParaLinguaDoI':
/home/santana/asciibook/linguagem-de-programacao-i-livro/livro/capitulos/code/cap5/etapa5/src/lingua-do-i-test.c:24: undefined reference to `traduzParaLingaDoI'
collect2: ld returned 1 exit status
make: ** [lingua-do-i-test] Erro 1
....

Criando função `traduzParaLingaDoI`::
Adição da definição no cabeçalho e implementação estúpida no arquivo
core.
+
Compilando e executando o teste para descobrir o próximo passo:
+
....
$ make clean && make lingua-do-i-test && ./lingua-do-i-test
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
lingua-do-i-test: lingua-do-i-test.c:8: verificaConteudosSaoIguais: Assertion `conteudo != ((void *)0) && "conteúdo não pode ser NULL"' failed.
Abortado (imagem do núcleo gravada)
....

==== Código da etapa

Você pode consultar o código final desta etapa nos seguintes
arquivos:

.Código fonte
{online}/{etapa}/src/lingua-do-i.c[{local}/{etapa}/src/lingua-do-i.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-test.c[{local}/{etapa}/src/lingua-do-i-test.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.c[{local}/{etapa}/src/lingua-do-i-core.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.h[{local}/{etapa}/src/lingua-do-i-core.h]

.Código fonte
{online}/{etapa}/src/musica-trecho.txt[{local}/{etapa}/src/musica-trecho.txt]

.Código fonte
{online}/{etapa}/src/Makefile[{local}/{etapa}/src/Makefile]


=== Etapa 6: Fazendo o teste passar

:etapa: etapa6


==== Fazendo o teste passar
Alteramos a função `traduzParaLingaDoI` para retornar o valor
esperado.

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.c[{local}/{etapa}/src/lingua-do-i-core.c]

[source,c]
----
char* TRADUCAO="Minhis vigiis, tidi iqui.";
char* traduzParaLingaDoI(char* mensagemOriginal){
	return TRADUCAO;
}
----

.Execução do teste após modificação
....
$ make clean && make lingua-do-i-test && ./lingua-do-i-test
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o
lingua-do-i-test
....

Ótimo, nosso teste está passando! 

==== Código da etapa

Você pode consultar o código final desta etapa nos seguintes
arquivos:

.Código fonte
{online}/{etapa}/src/lingua-do-i.c[{local}/{etapa}/src/lingua-do-i.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-test.c[{local}/{etapa}/src/lingua-do-i-test.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.c[{local}/{etapa}/src/lingua-do-i-core.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.h[{local}/{etapa}/src/lingua-do-i-core.h]

.Código fonte
{online}/{etapa}/src/musica-trecho.txt[{local}/{etapa}/src/musica-trecho.txt]

.Código fonte
{online}/{etapa}/src/Makefile[{local}/{etapa}/src/Makefile]


=== Etapa 7: Implementando troca das vogais

:etapa: etapa7

==== Implementando troca das vogais

Inclusão de <<string_h>>, pois vamos usar a função <<strlen>>.

Atualiza `traduzParaLingaDoI` 

[source,c]
----
char* traduzParaLingaDoI(char* mensagemOriginal){ 
	int tamanhoDaMensagem = strlen(mensagemOriginal);
	char* resposta = calloc(1, tamanhoDaMensagem+1);
	for(int i=0; i<tamanhoDaMensagem; i++){
		char caracterDaMensagemOriginal = mensagemOriginal[i];
		resposta[i] = traduzCaracterParaLinguaDoI(
				caracterDaMensagemOriginal);
	}
	return resposta;
}
----


Cria `traduzCaracterParaLinguaDoI`

[source,c]
----
char traduzCaracterParaLinguaDoI(char original){ 
	char resposta;
	switch (original) {
	case 'a':
	case 'e':
	case 'i':
	case 'o':
	case 'u':
		resposta = 'i';
		break;
	default:
		resposta = original;
	}
	return resposta;
}
----

.Apesar da nossa implementação o erro continua
....
include::{local}/{etapa}/make-command.txt[]
....

==== Código da etapa

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.c[{local}/{etapa}/src/lingua-do-i-core.c]

[source, c]
----
include::{local}/{etapa}/src/lingua-do-i-core.c[]
----
<1> Inclusão de `string.h`
<2> Criação de função para traduzir um carácter.
<3> Implementação real da função de traduzir
<4> Optamos por criar uma nova mensagem como resposta, ao invés de
    alterar a mensagem original.

==== Código da etapa

Você pode consultar o código final desta etapa nos seguintes
arquivos:

.Código fonte
{online}/{etapa}/src/lingua-do-i.c[{local}/{etapa}/src/lingua-do-i.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-test.c[{local}/{etapa}/src/lingua-do-i-test.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.c[{local}/{etapa}/src/lingua-do-i-core.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.h[{local}/{etapa}/src/lingua-do-i-core.h]

.Código fonte
{online}/{etapa}/src/musica-trecho.txt[{local}/{etapa}/src/musica-trecho.txt]

.Código fonte
{online}/{etapa}/src/Makefile[{local}/{etapa}/src/Makefile]


[[sec_etapa8]]
=== Etapa 8: Depurando a aplicação
:etapa: etapa8

Apesar da nossa simples implementação aparentar está correta, por uma
razão ainda desconhecida o nosso teste está falhando.

Esta é uma boa oportunidade para *((Depurar))* a execução do programa.
A depuração será abordada em um capítulo a parte: <<cap_depuracao>>. O
processo de depuração permite-nos identificar sem precisar alterar o
código inserindo várias mensagens do tipo:

  printf("passou por aqui...")
  printf("O valor de var=%d",var)

TIP: Apesar de não ser um pré-requisito para continuação deste
capítulo, convidamos você a ler o <<cap_depuracao>> antes de
continuar, para conhecer o processo de depuração.

==== Depuração do programa
A depuração do programa pode ser vista na <<sec_depuracao>> e a
identificação do problema na <<sec_depuracao_resultado>>.

==== Correção e verificação do teste passando

Após a correção do código fonte, executamos o teste novamente:

.Re-executando o teste após a correção
....
$ make clean && make && ./lingua-do-i-test 
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i.c lingua-do-i-core.c -o lingua-do-i
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
....

Nosso teste está passando novamente!

[[sec_etapa8_codigo]]
==== Código

.Código fonte
{online}/{etapa}/src/lingua-do-i-test.c[{local}/{etapa}/src/lingua-do-i-test.c]

[source, c]
.Código fonte para os testes
----
include::{local}/{etapa}/src/lingua-do-i-test.c[]
----
<1> Correção realizada

==== Código da etapa

Você pode consultar o código final desta etapa nos seguintes
arquivos:

.Código fonte
{online}/{etapa}/src/lingua-do-i.c[{local}/{etapa}/src/lingua-do-i.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-test.c[{local}/{etapa}/src/lingua-do-i-test.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.c[{local}/{etapa}/src/lingua-do-i-core.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.h[{local}/{etapa}/src/lingua-do-i-core.h]

.Código fonte
{online}/{etapa}/src/musica-trecho.txt[{local}/{etapa}/src/musica-trecho.txt]

.Código fonte
{online}/{etapa}/src/Makefile[{local}/{etapa}/src/Makefile]

[[sec_etapa9]]
=== Etapa 9: Inclusão de novos testes

Após a correção, nossos testes estão passando. Mas será que a
implementação de `traduzParaLingaDoI` está correta?  Vamos adicionar
novos testes para garantir isso.

==== Adição de testes

[source,c]
----
char* MENSAGEM_ORIGINAL2 = "Oh! Deus, será que o senhor se zangou";
char* TRADUCAO_ESPERADA2= "Ih! Diis, sirí qii i sinhir si zingii";
void testTraducaoParaLinguaDoI(){
	char* mensagemTraduzida = traduzParaLingaDoI(MENSAGEM_ORIGINAL);
	verificaConteudosSaoIguais(mensagemTraduzida, TRADUCAO_ESPERADA);
	verificaConteudosSaoIguais(traduzParaLingaDoI(MENSAGEM_ORIGINAL2), TRADUCAO_ESPERADA2);
}
----

==== Execução do teste

.Execução do teste
....
$ make clean && make && ./lingua-do-i-test 
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i.c lingua-do-i-core.c -o lingua-do-i
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
lingua-do-i-test: lingua-do-i-test.c:11: verificaConteudosSaoIguais: Assertion `strcmp(conteudo, esperado) == 0 && "conteúdo deve ser igual ao esperado"' failed.
Abortado (imagem do núcleo gravada)
....

Como a falha ocorreu devido a inclusão do novo teste, isto que dizer
que precisamos atualizar a implementação para fazer o teste passar.

==== Atualizar a implementação para fazer o teste passar

A diferença do teste adicionado é que ele adiciona uma vogal
maiúscula, e outra vogal com acento: *``Oh! Deus, será''*.

Vamos atualizar nossa implementação para possibilitar esta conversão
também:

[source,c]
....
char traduzCaracterParaLinguaDoI(char original){
	char resposta;
	switch (original) {
	case 'a':
	case 'e':
	case 'i':
	case 'o':
	case 'u':
		resposta = 'i';
		break;
	case 'A':
	case 'E':
	case 'I':
	case 'O':
	case 'U':
		resposta = 'I'; // <1>
		break;
	case 'á':
	case 'é':
	case 'í':
	case 'ó':
	case 'ú':
		resposta = 'í'; // <2>
		break;
	default:
		resposta = original;
	}
	return resposta;
}
....

<1> Inclusão de conversão de letra maiúscula.
<2> Conversão de caracteres com acentos.

==== Execução dos testes após modificação
.Execução dos testes após modificação
....
$ make clean && make && make test_all
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i.c lingua-do-i-core.c -o lingua-do-i
lingua-do-i-core.c: Na função ‘traduzCaracterParaLinguaDoI’:
lingua-do-i-core.c:64:7: aviso: constante de caractere multi-caractere [-Wmultichar]
lingua-do-i-core.c:64:2: aviso: case label value exceeds maximum value for type [habilitado por padrão]
lingua-do-i-core.c:65:7: aviso: constante de caractere multi-caractere [-Wmultichar]
lingua-do-i-core.c:65:2: aviso: case label value exceeds maximum value for type [habilitado por padrão]
lingua-do-i-core.c:66:7: aviso: constante de caractere multi-caractere [-Wmultichar]
lingua-do-i-core.c:66:2: aviso: case label value exceeds maximum value for type [habilitado por padrão]
lingua-do-i-core.c:67:7: aviso: constante de caractere multi-caractere [-Wmultichar]
lingua-do-i-core.c:67:2: aviso: case label value exceeds maximum value for type [habilitado por padrão]
lingua-do-i-core.c:68:7: aviso: constante de caractere multi-caractere [-Wmultichar]
lingua-do-i-core.c:68:2: aviso: case label value exceeds maximum value for type [habilitado por padrão]
lingua-do-i-core.c:69:14: aviso: constante de caractere multi-caractere [-Wmultichar]
lingua-do-i-core.c:69:3: aviso: overflow in implicit constant conversion [-Woverflow]
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
lingua-do-i-core.c: Na função ‘traduzCaracterParaLinguaDoI’:
lingua-do-i-core.c:64:7: aviso: constante de caractere multi-caractere [-Wmultichar]
lingua-do-i-core.c:64:2: aviso: case label value exceeds maximum value for type [habilitado por padrão]
lingua-do-i-core.c:65:7: aviso: constante de caractere multi-caractere [-Wmultichar]
lingua-do-i-core.c:65:2: aviso: case label value exceeds maximum value for type [habilitado por padrão]
lingua-do-i-core.c:66:7: aviso: constante de caractere multi-caractere [-Wmultichar]
lingua-do-i-core.c:66:2: aviso: case label value exceeds maximum value for type [habilitado por padrão]
lingua-do-i-core.c:67:7: aviso: constante de caractere multi-caractere [-Wmultichar]
lingua-do-i-core.c:67:2: aviso: case label value exceeds maximum value for type [habilitado por padrão]
lingua-do-i-core.c:68:7: aviso: constante de caractere multi-caractere [-Wmultichar]
lingua-do-i-core.c:68:2: aviso: case label value exceeds maximum value for type [habilitado por padrão]
lingua-do-i-core.c:69:14: aviso: constante de caractere multi-caractere [-Wmultichar]
lingua-do-i-core.c:69:3: aviso: overflow in implicit constant conversion [-Woverflow]
./lingua-do-i-test
lingua-do-i-test: lingua-do-i-test.c:11: verificaConteudosSaoIguais: Assertion `strcmp(conteudo, esperado) == 0 && "conteúdo deve ser igual ao esperado"' failed.
make: *** [test_all] Abortado (arquivo core criado)
....

Quando executamos o teste, verificamos que o compilador apresentou
vários avisos e o teste falhou.

==== Código da etapa

Você pode consultar o código final desta etapa nos seguintes
arquivos:

.Código fonte
{online}/{etapa}/src/lingua-do-i.c[{local}/{etapa}/src/lingua-do-i.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-test.c[{local}/{etapa}/src/lingua-do-i-test.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.c[{local}/{etapa}/src/lingua-do-i-core.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.h[{local}/{etapa}/src/lingua-do-i-core.h]

.Código fonte
{online}/{etapa}/src/musica-trecho.txt[{local}/{etapa}/src/musica-trecho.txt]

.Código fonte
{online}/{etapa}/src/Makefile[{local}/{etapa}/src/Makefile]


=== Etapa 10: Tratando texto com acentos

:etapa: etapa10

Na etapa anterior percebemos que a utilização de acentos provocou
falha no nosso teste.

Para compreender o problema precisamos entender sobre
*((codificação))* de arquivos.

Enquanto caracteres ASCII são facilmente codificados, pois cada
carácter possui um único byte (que corresponde ao tamanho de um
`char`), outras codificações, como UTF-8, podem possuir carácteres com
tamanhos diferentes. Alem disso, pode existir mais de uma codificação
para o mesmo carácter.

Por enquanto nós iremos utilizar o ((Algorítmo do Avestruz)) para
resolução de problemas: nós iremos ignorar o problema e continuar
nossa implementação ignorando o tratamento de acentos. Depois, quando
tivermos conhecimento suficiente para tratar este problema poderemos
voltar a ele.

TIP: Você conhecer mais sobre o *Algorítmo do Avestruz* em
http://pt.wikipedia.org/wiki/Algoritmo_do_avestruz.


==== Desfazer teste com acentos
[source,c]
----
char* MENSAGEM_ORIGINAL2="Oh! Deus, será que o senhor se zangou";
char* TRADUCAO_ESPERADA2="Ih! Diis, sirá qii i sinhir si zingii";<1>
----
<1> Substituição do `í` por `á`. Por enquanto nosso programa não irá
    tratar acentos. 

==== Desfazer implementação de core que tratava acentos

[source,c]
----
char traduzCaracterParaLinguaDoI(char original){
	char resposta;

	switch (original) {
	case 'a':
	case 'e':
	case 'i':
	case 'o':
	case 'u':
		resposta = 'i';
		break;
	case 'A':
	case 'E':
	case 'I':
	case 'O':
	case 'U':
		resposta = 'I';
		break;
	default:
		resposta = original;
	}

	return resposta;
}
----
==== Re-execução dos testes

.Re-execução dos testes após remoção de tratamento de acentos
....
$ make clean && make && make test_all
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i.c lingua-do-i-core.c -o lingua-do-i
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o
lingua-do-i-test
./lingua-do-i-test
....

==== Criação de arquivo TODO

Criamos um arquivo entitulado `TODO.txt` que manterá registro de
atividades que gostaríamos de realizar no futuro:

.Código fonte
{online}/{etapa}/src/lingua-do-i.c[{local}/{etapa}/TODO.txt]

[source, c]
.Criação do arquivo TODO.txt
....
include::{local}/{etapa}/TODO.txt[]
....

A criação de um arquivo *TODO* possibilita comunicar para as demais
pessoas (envolvidas ou que irão se envolver no projeto) onde elas
podem contribuir para o projeto.

===== Código do teste
.Código fonte
{online}/{etapa}/src/lingua-do-i-test.c[{local}/{etapa}/src/lingua-do-i-test.c]

[source, c]
----
include::{local}/{etapa}/src/lingua-do-i-test.c[]
----

===== Código do core
.Código fonte
{online}/{etapa}/src/lingua-do-i-test.c[{local}/{etapa}/src/lingua-do-i-core.c]

[source, c]
----
include::{local}/{etapa}/src/lingua-do-i-core.c[]
----

==== Código da etapa

Você pode consultar o código final desta etapa nos seguintes
arquivos:

.Código fonte
{online}/{etapa}/src/lingua-do-i.c[{local}/{etapa}/src/lingua-do-i.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-test.c[{local}/{etapa}/src/lingua-do-i-test.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.c[{local}/{etapa}/src/lingua-do-i-core.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.h[{local}/{etapa}/src/lingua-do-i-core.h]

.Código fonte
{online}/{etapa}/src/musica-trecho.txt[{local}/{etapa}/src/musica-trecho.txt]

.Código fonte
{online}/{etapa}/src/Makefile[{local}/{etapa}/src/Makefile]


=== Etapa 11: Salvando conteúdo em arquivo
:etapa: etapa11

Além de traduzir mensagens nosso programa também precisa salvar seu
conteúdo em arquivo. Nesta etapa vamos atualizar nossa implementação
para possibilitar o salvamento.

==== Adicionar teste de salvamento de conteúdo

Mas uma vez, antes de iniciar a implementação da nossa funcionalidade
iremos escrever um teste para ela.

[source, c]
.Adicionando teste de salvamento de arquivo em lingua-do-i-test.c
----
void verificaConteudoFoiSalvo( FILE* arquivo, 
    char* conteudo_esperado ){
  char* conteudo = lerConteudoDeArquivoArberto(arquivo); <1>
  assert( strcmp(conteudo, conteudo_esperado) == 0
    && "Conteúdo do arquivo não corresponde ao esperado");
}

FILE * criaArquivoTemporario(){
	return tmpfile();
}

char* CONTEUDO_QUALQUER = "abracadabra";
void testSalvaConteudoEmArquivo(){
  FILE * arquivoDestino = criaArquivoTemporario(); <2>
  salvaConteudo(arquivoDestino, CONTEUDO_QUALQUER); <3>
  verificaConteudoFoiSalvo(arquivoDestino, CONTEUDO_QUALQUER); <4>

  fclose(arquivoDestino); <5>
}
----
<1> A função `lerConteudoDeArquivoArberto` foi implementada em
    `lingua-do-i-core.c`, mas ainda não está visível aqui,
    precisaremos adicioná-la ao cabeçalho mais adiante.
<2> Criação de um arquivo temporário para o teste, o conteúdo do teste
    será escrito nele. Se estivéssemos utilizando um arquivo normal,
    deveríamos nos certificar de que o arquivo não existia antes, em
    decorrência de execuções anteriores. Arquivos temporários são bons
    para os testes pois quando fechados são automaticamente excluídos.
<3> Esta função será implementada no core. Percebam que escrevemos a
    função sem passar o nome do arquivo, mas um parâmetro do tipo
    `File*`. Decidimos assim, pois pretendemos salvar o conteúdo
    também na saída padrão (que é do tipo `File*`). 
<4> Função para verificar que o conteúdo escrito no arquivo
    corresponde ao conteúdo passado para a função `salvaConteudo`.
<5> Fechamento do arquivo.


==== Atualização do arquivo de cabeçalho do core
Sabemos que temos algumas alterações pendentes para serem realizadas
no arquivo de cabeçalho do core, vamos realizá-las agora:

[source,c]
.Atualização de lingua-do-i-core.h
----
void salvaConteudo(FILE* arquivoDestino, char* conteudo); <1>
char* lerConteudoDeArquivoArberto(FILE* arquivo); <2>
----
<1> Função que desejamos implementar
<2> Declaração de função já implementada em core mas que não estava
    visível externamente ao arquivo.

==== Implementação vazia para possibilitar teste falhar

Antes de compilar e executar o teste, precisamos ainda criar uma
implementação vazia de `salvaConteudo`:

[source,c]
.Implementação vazia em lingua-do-i-core.c
----
void salvaConteudo(FILE* arquivoDestino, char* conteudo){
}
----

==== Verificando o teste falhando

Com a implementação da função realizada, vamos compilar os arquivos e
executar os testes:

.Compilação e execução dos testes
....
$ make clean && make && ./lingua-do-i-test 
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i.c lingua-do-i-core.c -o lingua-do-i
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o
lingua-do-i-test
lingua-do-i-test: lingua-do-i-test.c:28: verificaConteudoFoiSalvo:
Assertion `strcmp(conteudo, conteudo_esperado) == 0 && "Conteúdo do
arquivo não corresponde ao esperado"' failed.
Abortado (imagem do núcleo gravada)
....

Como esperado, o teste falhou pois a função que deveria escrever o
conteúdo está vazia.

==== Fazendo o teste passar

Desta vez não há uma forma simples de fazer o teste passar, precisamos
realmente escrever o conteúdo no arquivo para que o teste passe.

Então implementamos a função `salvaConteudo` da seguinte forma:

[source,c]
.Implementação para escrever conteúdo no arquivo
----
void salvaConteudo(FILE* arquivoDestino, char* conteudo){
  fprintf(arquivoDestino, "%s", conteudo);
}
----

TIP: A função <<fprintf>> é similar a <<printf>>, a única diferença é
que `printf` escreve sempre na saída padrão, enquanto que `fprintf`
recebe como parâmetro qual o arquivo onde será escrito o conteúdo.

.Execução do teste
....
$ make clean && make && ./lingua-do-i-test 
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i.c lingua-do-i-core.c -o lingua-do-i
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
....

Ótimo, nossos testes estão passando novamente!

==== Código da etapa

Você pode consultar o código final desta etapa nos seguintes
arquivos:

.Código fonte
{online}/{etapa}/src/lingua-do-i.c[{local}/{etapa}/src/lingua-do-i.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-test.c[{local}/{etapa}/src/lingua-do-i-test.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.c[{local}/{etapa}/src/lingua-do-i-core.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.h[{local}/{etapa}/src/lingua-do-i-core.h]

.Código fonte
{online}/{etapa}/src/musica-trecho.txt[{local}/{etapa}/src/musica-trecho.txt]

.Código fonte
{online}/{etapa}/src/Makefile[{local}/{etapa}/src/Makefile]

=== Etapa 12: Determinando entrada do aplicativo

:etapa: etapa12

Nesta etapa vamos definir como o programa irá determinar qual a
entrada será processada, se utilizará a entrada padrão ou a partir de
um arquivo.

Caso o aplicativo seja invocado sem nenhum parâmetro, ele irá ler da
entrada padrão, caso seja especificado o nome de um arquivo, ele será
utilizado.

==== Testes para especificar a entrada

No código a serguir estão definidos 3 testes, que utilizando os
parâmetros passados pelo sistema operacional à função <<sec_main>>,
tente compreender o significado deles:

[source,c]
.Testes para determinar a entrada do programa
----
int ARGC_SEM_PARAMETROS  = 1;
const char* ARGV_SEM_PARAMETROS[] = {"lingua-do-i"};
void testDefinirEntradaPadrao(){
	FILE* entrada = determinaEntrada(ARGC_SEM_PARAMETROS,
		ARGV_SEM_PARAMETROS);
	verificaEntradaFoiEntradaPadrao(entrada);
}

int ARGC_COM_1_PARAMETRO = 2;
const char* ARGV_ARQUIVO_VALIDO[] =
	{"lingua-do-i", "musica-trecho.txt"};
const char* ARGV_ARQUIVO_INEXISTENTE[] =
	{"lingua-do-i", "inexistente.xyz"};
void testDefinirEntradaDeArquivo(){
	FILE* entrada = determinaEntrada(ARGC_COM_1_PARAMETRO,
		ARGV_ARQUIVO_VALIDO);
	verificaEntradaFoiArquivoValido(entrada);
}

void testDefinirEntradaDeArquivoInexistente(){
	FILE* entrada = determinaEntrada(ARGC_COM_1_PARAMETRO,
		ARGV_ARQUIVO_INEXISTENTE);
	verificaEntradaFoiInvalida(entrada);
}
----

Os três testes estão invocando a função `determinaEntrada`, que ainda
será implementada no core, mas que terá a responsabilidade de
determinar a entrada do aplicativo a partir dos parâmetros passados à
função <<sec_main>>:

testDefinirEntradaPadrao::
Neste teste estamos definindo que se o programa for executado sem
nenhum parâmetro, ele irá ler da entrada padrão.

testDefinirEntradaDeArquivo::
Caso o programa seja invocado passando o nome do arquivo, ele será
utilizado como entrada.

testDefinirEntradaDeArquivoInexistente::
Caso seja passando o nome do arquivo, mas ele não exista, então o
programa não poderá processar a entrada.

TIP: Perceba como os nomes das funções facilitam na compreenção do
código. É preferível que você crie várias funções pequenas com
responsabilidades bem definidas do que uma poucas funções com muitas
responsabilidades.

Por último, também é necessário invocá-los a partir do main:

[source,c]
.Invocando os testes a partir do main
----
int main(void) {
	...
	testDefinirEntradaPadrao();
	testDefinirEntradaDeArquivo();
	testDefinirEntradaDeArquivoInexistente();

	return EXIT_SUCCESS;
}
----

==== Fazendo os testes falharem

Uma vez definido os testes, nosso próximo passo é fazê-los compilarem
e falharem.

Para fazer os testes compilarem precisamos da ajuda do compilador,
utilizaremos as notificações de problemas de compilação para
descobrir o próximo passo:

.Invocando o compilador para descobrir o próximo passo
....
$ make clean && make && make test_all
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i.c lingua-do-i-core.c -o lingua-do-i
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
lingua-do-i-test.c: Na função ‘testDefinirEntradaPadrao’:
lingua-do-i-test.c:54:2: aviso: implicit declaration of function ‘determinaEntrada’ [-Wimplicit-function-declaration]
...
....

O compilador nos informou que a  função `determinaEntrada` ainda não
existe, precisamos defini-la no cabeçalho e criá-la no core:

[source,c]
.Definindo determinaEntrada no cabeçalho
----
FILE* determinaEntrada(int argc, const char* argv[]);
----

[source,c]
.Implementando determinaEntrada no core
----
FILE* determinaEntrada(int argc, const char* argv[]){
	return NULL;
}
----

Vamos invocar a compilação novamente:

....
$ make clean && make && make test_all
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i.c lingua-do-i-core.c -o lingua-do-i
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
lingua-do-i-test.c: Na função ‘testDefinirEntradaPadrao’:
lingua-do-i-test.c:56:2: aviso: implicit declaration of function ‘verificaEntradaFoiEntradaPadrao’ [-Wimplicit-function-declaration]
...
....

Desobrimos que o próximo passo é criar a função
`verificaEntradaFoiEntradaPadrao`:

[source,c]
----
void verificaEntradaFoiEntradaPadrao(FILE* entrada){
	assert(entrada == stdin && 
	    "Entrada deveria ser Entrada Padrão");
}
----

Compilando para descobrir o próximo passo:

....
$ make clean && make && make test_all
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i.c lingua-do-i-core.c -o lingua-do-i
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
lingua-do-i-test.c: Na função ‘testDefinirEntradaDeArquivo’:
lingua-do-i-test.c:69:2: aviso: implicit declaration of function ‘verificaEntradaFoiArquivoValido’ [-Wimplicit-function-declaration]
...
....

O erro anterior foi corrigido, agora o compilador nos informa que
precisamos implementar a função `verificaEntradaFoiArquivoValido`:

[source,c]
.Implementação de verificaEntradaFoiArquivoValido no teste
----
void verificaEntradaFoiArquivoValido(FILE* entrada){
	assert(entrada != NULL && entrada!= stdin &&
		"Entrada deveria ser um arquivo válido");
}
----


Mais uma vez, compilando para descobrir o próximo passo:

....
$ make clean && make && make test_all
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i.c lingua-do-i-core.c -o lingua-do-i
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
lingua-do-i-test.c: Na função ‘testDefinirEntradaDeArquivoInexistente’:
lingua-do-i-test.c:80:2: aviso: implicit declaration of function ‘verificaEntradaFoiInvalida’ [-Wimplicit-function-declaration]
...
....

Novamente, precisamos implementar outra função:

[source,c]
.Implementação da função
----
void verificaEntradaFoiInvalida(FILE* entrada){
	assert(entrada == NULL && "Entrada deve ser inválida");
}
----

.Compilando para descobrir o próximo passo
....
$ make clean && make && make test_all
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i.c lingua-do-i-core.c -o lingua-do-i
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
./lingua-do-i-test
lingua-do-i-test: lingua-do-i-test.c:52: verificaEntradaFoiEntradaPadrao: Assertion `entrada == stdin && "Entrada deveria ser Entrada Padrão"' failed.
make: *** [test_all] Abortado (arquivo core criado)
...
....

Ótimo! O código já está compilando e nosso primeiro teste está
falhando. Para verificar os outros testes falhando, basta comentar a
linha de invocação do teste na função `main`:

[source,c]
.Comentando teste para verificar que os demais estão falhando
----
int main(void) {
	testLerConteudoDoArquivo();
	testSalvaConteudoEmArquivo();
	testTraducaoParaLinguaDoI();

	//testDefinirEntradaPadrao();
	testDefinirEntradaDeArquivo();
	testDefinirEntradaDeArquivoInexistente();

	return EXIT_SUCCESS;
}
----

.Verificando o próximo teste falhando
....
$ make clean && make && make test_all
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i.c lingua-do-i-core.c -o lingua-do-i
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
./lingua-do-i-test
lingua-do-i-test: lingua-do-i-test.c:57: verificaEntradaFoiArquivoValido: Assertion `entrada != ((void *)0) && entrada!= stdin && "Entrada deveria ser um arquivo válido"' failed.
make: *** [test_all] Abortado (arquivo core criado)
....


Mais um teste falhando, falta apenas verificar o último.

[source,c]
----
int main(void) {
	testLerConteudoDoArquivo();
	testSalvaConteudoEmArquivo();
	testTraducaoParaLinguaDoI();

	//testDefinirEntradaPadrao();
	//testDefinirEntradaDeArquivo();
	testDefinirEntradaDeArquivoInexistente();

	return EXIT_SUCCESS;
}
--------

.Tentando verificar o último teste falhando
....
$ make clean && make && make test_all
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i.c lingua-do-i-core.c -o lingua-do-i
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
./lingua-do-i-test
....

O último teste não está falhando. Verificar que o teste está falhando
é uma etapa muito importantefootnote:[Para saber mais sobre os testes
falhando consulte
http://butunclebob.com/ArticleS.UncleBob.TheThreeRulesOfTdd.], vamos
modificar a implementação de `determinaEntrada` para garantir isso:

[source,c]
.Modificação em core para todos os testes falharem
----
FILE* determinaEntrada(int argc, const char* argv[]){
	FILE* resultadoParaFalhar;
	if (argc == 1){
		resultadoParaFalhar = stdout;
	}else{
		resultadoParaFalhar = stdin;
	}
	return resultadoParaFalhar;
}
----

Vamos re-executar o teste:

....
$ make clean && make && make test_all
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i.c lingua-do-i-core.c -o lingua-do-i
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
./lingua-do-i-test
lingua-do-i-test: lingua-do-i-test.c:62: verificaEntradaFoiInvalida: Assertion `entrada == ((void *)0) && "Entrada deve ser inválida"' failed.
make: *** [test_all] Abortado (arquivo core criado)
....

Após esta modificação todos os testes falham, estamos prontos para
avançar para a próxima etapa.

==== Código da etapa

Você pode consultar o código final desta etapa nos seguintes
arquivos:

.Código fonte
{online}/{etapa}/src/lingua-do-i.c[{local}/{etapa}/src/lingua-do-i.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-test.c[{local}/{etapa}/src/lingua-do-i-test.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.c[{local}/{etapa}/src/lingua-do-i-core.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.h[{local}/{etapa}/src/lingua-do-i-core.h]

.Código fonte
{online}/{etapa}/src/musica-trecho.txt[{local}/{etapa}/src/musica-trecho.txt]

.Código fonte
{online}/{etapa}/src/Makefile[{local}/{etapa}/src/Makefile]

=== Etapa 13: Fazendo os testes de entrada passarem
:etapa: etapa13


==== Fazendo os testes passarem

Antes de fazer o teste passar, vamos verificar o teste falhando
novamente:

.Verificando teste da entrada padrão falhando
....
$ make clean && make lingua-do-i-test && make test_all
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
./lingua-do-i-test
lingua-do-i-test: lingua-do-i-test.c:53: verificaEntradaFoiEntradaPadrao: Assertion `entrada == stdin && "Entrada deveria ser Entrada Padrão"' failed.
make: *** [test_all] Abortado (arquivo core criado)
....

Para o teste passar, precisamos retornar `stdin` quando o aplicativo
for invocado sem parâmetros:

[source, c]
----
FILE* determinaEntrada(int argc, const char* argv[]){
	FILE* entrada;
	if (argc == 1){
		entrada = stdin; <1>
	}else{
		entrada = stdin;
	}
	return entrada;
}
----
<1> Quando `argc == 1`, então não há nenhum parâmetro e devemos
    retornar a entrada padrão. 

Vamos executar os testes novamente:

.Re-execução dos testes
....
$ make clean && make lingua-do-i-test && make test_all
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
./lingua-do-i-test
lingua-do-i-test: lingua-do-i-test.c:58: verificaEntradaFoiArquivoValido: Assertion `entrada != ((void *)0) && entrada!= stdin && "Entrada deveria ser um arquivo válido"' failed.
make: *** [test_all] Abortado (arquivo core criado)
....

Ótimo, nosso primeiro teste passou, e a falha do segundo foi
apresentada. Próximo passo será fazer o segundo teste passar:

[source,c]
.Ajuste para fazer o segundo teste passar
----
FILE* determinaEntrada(int argc, const char* argv[]){
	FILE* entrada;
	if (argc == 1){
		entrada = stdin;
	}else{
		entrada = fopen(argv[1], "r"); <1>
	}
	return entrada;
}
----
<1> Utiliza <<fopen>> para abrir arquivo para leitura, utilizando o
    nome do arquivo passado como parâmetro.

.Re-execução dos testes
....
$ make clean && make lingua-do-i-test && make test_all
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
./lingua-do-i-test
....

Com esta última modificação todos os nossos testes estão passando! Na
próxima etapa iremos unir a implementação de core no `main()`.

==== Código da etapa

Você pode consultar o código final desta etapa nos seguintes
arquivos:

.Código fonte
{online}/{etapa}/src/lingua-do-i.c[{local}/{etapa}/src/lingua-do-i.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-test.c[{local}/{etapa}/src/lingua-do-i-test.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.c[{local}/{etapa}/src/lingua-do-i-core.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.h[{local}/{etapa}/src/lingua-do-i-core.h]

.Código fonte
{online}/{etapa}/src/musica-trecho.txt[{local}/{etapa}/src/musica-trecho.txt]

.Código fonte
{online}/{etapa}/src/Makefile[{local}/{etapa}/src/Makefile]

=== Etapa 14: Implementando aplicaçaõ da lingua-do-i
:etapa: etapa14

==== Construindo o main

Agora que já possuímos várias funções implementadas vamos
incorporá-las ao `main` da aplicação.

[source, c]
----
#include <stdio.h>
#include <stdlib.h>
#include "lingua-do-i-core.h" <1>

int main(int argc, const char* argv[]) {<2>

	FILE* entrada = determinaEntrada(argc, argv);

	if (entrada){<3>
		char* conteudo=lerConteudoDeArquivoArberto(entrada);<4>
		char* mensagem = traduzParaLingaDoI(conteudo);<4>
		salvaConteudo(stdout, mensagem);<5>
	}else{
		fprintf(stderr, "Problema ao abrir arquivo: %s\n",
				argv[1]);<6>
		exit(EXIT_FAILURE);<6>
	}

	return EXIT_SUCCESS;
}
----

<1> Nosso primeiro passo é incluir o cabeçalho de core, para poder
    utilizar as funções definidas lá.
<2> Atualizamos o cabeçalho do `main`, adicionando os parâmetros que
    serão atribuídos pelo sistema operacional ao invocar a aplicação.
<3> Em C é comum a checagem de parâmetros desta forma, caso o
    parâmetro seja diferente de zero ou `NULL`, então é um valor válido.
<4> Ler conteúdo da entrada e traduz para língua do i
<5> Salva a mensagem traduzida na saída padrão, o usuário poderá
    redirecionar para um arquivo se desejar.
<6> Caso o arquivo não exista, a aplicação finaliza com mensagem de
    erro.

A seguir você pode conferir a compilação com sucesso da aplicação:

.Compilação de lingua-do-i
....
$ make clean && make && make test_all
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i.c lingua-do-i-core.c -o lingua-do-i
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
./lingua-do-i-test
....



==== Executando lingua-do-i

Primeiro vamos testar a tradução lendo de um arquivo passado como
parâmetro:

.Lendo de arquivo passado como parâmetro
....
$ ./lingua-do-i musica-trecho.txt 
Ih! Diis, pirdii isti pibri ciitidi
....

Em seguida, vamos testar ler da entrada padrão, direcionada de um
arquivo:

....
$ ./lingua-do-i < musica-trecho.txt 
Ih! Diis, pirdii isti pibri ciitidi
....

Ainda faltamos testar se foi passado um arquivo que não existe:

....
$ ./lingua-do-i arquivo-que-nao-existe.txt
Problema ao abrir arquivo: arquivo-que-nao-existe.txt
....

Nosso aplicativo foi capaz de ler de um arquivo, passado como
parâmetro ou lendo direcionado pela entrada padrão, mas será que ele é
capaz de ler a partir da entrada padrão sem ser direcionado de um
arquivo? Vamos fazer o teste!

Tentando ler da entrada padrão:
....
$ cat musica-trecho.txt | ./lingua-do-i
....

O resultado esperado não foi satisfatório, ele deveria ser capaz de
ler da entrada padrão, o que está errado com a nossa implementação?

==== Código da etapa

Você pode consultar o código final desta etapa nos seguintes
arquivos:

.Código fonte
{online}/{etapa}/src/lingua-do-i.c[{local}/{etapa}/src/lingua-do-i.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-test.c[{local}/{etapa}/src/lingua-do-i-test.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.c[{local}/{etapa}/src/lingua-do-i-core.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.h[{local}/{etapa}/src/lingua-do-i-core.h]

.Código fonte
{online}/{etapa}/src/musica-trecho.txt[{local}/{etapa}/src/musica-trecho.txt]

.Código fonte
{online}/{etapa}/src/Makefile[{local}/{etapa}/src/Makefile]


=== Etapa 15: Processando entrada por fluxo

:etapa: etapa15


==== Incluindo teste para tradução de fluxo

Neste teste, estamos desejando implementar uma função
`traduzFluxoDeEntradaNaSaida` que irá traduzir a mensagem de entrada e
salvar a tradução na saída.  

[source,c]
.Teste de tradução de fluxo
----
char* MUSICA_COMPLETA = "musica-completa.txt";
char* MUSICA_COMPLETA_TRAUDIZADA = "musica-completa-traduzida.txt";
void testTraduzFluxoDeEntrada(){

	FILE* entrada = fopen(MUSICA_COMPLETA,"r");
	FILE* saida = tmpfile();
	traduzFluxoDeEntradaNaSaida(entrada,saida);

	verificaMusicaFoiTraduzidaCorretamenteNaSaida(saida,
			MUSICA_COMPLETA_TRAUDIZADA);

	fclose(entrada);
	fclose(saida);
}
----

Para garantir a tradução correta, criamos um arquivo temporário para
servir como saída da função, em seguida,
`verificaMusicaFoiTraduzidaCorretamenteNaSaida` irá ler o conteúdo
escrito em `saida` e verificar o conteúdo do arquivo
`MUSICA_COMPLETA_TRAUDIZADA`:

[source,c]
----
void verificaMusicaFoiTraduzidaCorretamenteNaSaida(
    FILE* fluxo, char* arquivoComTraducaoCorreta){
  
  rewind(fluxo); // volta para ler do início da saída
  char* conteudo=lerConteudoDeArquivoArberto(fluxo);
  char* traducao=lerConteudoDoArquivo(arquivoComTraducaoCorreta);

  assert( strcmp(conteudo, traducao) == 0
      && "Arquivo deve ser traduzido corretamente");
}
----

==== Salvando a letra da música e sua tradução

.Música completa
....
Oh! Deus, perdoe este pobre coitado
Que de joelhos rezou um bocado
Pedindo pra chuva cair sem parar

(...)

Desculpe eu pedir a toda hora pra chegar o inverno
Desculpe eu pedir para acabar com o inferno
Que sempre queimou o meu Ceará
....

.Música traduzida
....
Ih! Diis, pirdii isti pibri ciitidi
Qii di jiilhis rizii im bicidi
Pidindi pri chivi ciir sim pirir

(...)

Discilpi ii pidir i tidi hiri pri chigir i invirni
Discilpi ii pidir piri icibir cim i infirni
Qii simpri qiiimii i mii Ciirá
....

NOTE: Ainda não estamos tratando vogais acentuadas.

==== Fazendo o teste falhar

.Compilando o código
....
$ make clean && make lingua-do-i-test && make test_all 
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
lingua-do-i-test.c: Na função ‘testTraduzFluxoDeEntrada’:
lingua-do-i-test.c:107:2: aviso: implicit declaration of function ‘traduzFluxoDeEntradaNaSaida’ [-Wimplicit-function-declaration]
/tmp/ccPNDB7P.o: In function `testTraduzFluxoDeEntrada':
/home/santana/livro/capitulos/code/cap5/etapa15/src/lingua-do-i-test.c:107: undefined reference to `traduzFluxoDeEntradaNaSaida'
collect2: ld returned 1 exit status
make: ** [lingua-do-i-test] Erro 1
....

O compilador nos avisou que precisamos criar a função
`traduzFluxoDeEntradaNaSaida`:

[source,c]
.Atualização do cabeçalho
----
void traduzFluxoDeEntradaNaSaida(FILE* entrada, FILE* saida);
----

[source,c]
.Criando função vazia no core
----
void traduzFluxoDeEntradaNaSaida(FILE* entrada, FILE* saida){
}
----

.Compilando e executando teste
....
$ make clean && make lingua-do-i-test && make test_all 
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
./lingua-do-i-test
lingua-do-i-test: lingua-do-i-test.c:98: verificaMusicaFoiTraduzidaCorretamenteNaSaida: Assertion `strcmp(conteudo, traducao) == 0 && "Arquivo deve ser traduzido corretamente"' failed.
make: *** [test_all] Abortado (arquivo core criado)
....

Ótimo, nosso teste está falhando!

==== Fazendo o teste passar
Uma vez que nosso teste está falhando, o próximo passo é fazê-lo
passar com o esforço mínimo. Para isso, vamos atualizar a função
`traduzFluxoDeEntradaNaSaida` para escrever na saída o valor que
esperamos:

[source,c]
.Fazendo o teste passar com esforço mínimo
----
void traduzFluxoDeEntradaNaSaida(FILE* entrada, FILE* saida){
	char* traducao = lerConteudoDoArquivo("musica-completa-traduzida.txt");
	int tamanhoDaTraducao = strlen(traducao);
	fwrite(traducao,1,tamanhoDaTraducao,saida);
}
----

Executando o teste para verificar passando:

.Verificação do teste passando
....
$ make clean && make lingua-do-i-test && make test_all 
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
./lingua-do-i-test
....

Ótimo! Nossos testes estão passando novamente. Agora precisamos
substituir a implementação da função por outra que continue passando.

==== Implementando tradução por fluxo

Quando estamos tratando um fluxo, precisamos lê-lo por partes. Só
podemos ler uma outra parte após tratar a anterior. Em nosso caso,
vamos dividir o fluxo em linhas. Ficaremos em _loop_, lendo uma linha,
traduzindo-a e salvando a tradução na saída, até que cheguemos ao
final da entrada:

[source,c]
.Tradução do fluxo por linhas
----
void traduzFluxoDeEntradaNaSaida(FILE* entrada, FILE* saida){
	while (naoChegouNoFinal(entrada)){
		char* linha = lerLinhaDaEntrada(entrada);
		char* traducao = traduzParaLingaDoI(linha);
		salvaConteudoNaSaida(traducao,saida);
	}
}
----

Enquanto estamos lendo do fluxo de entrada, precisamos processá-lo
enquanto não chegou no final, implementado na função que se segue:

[source,c]
----
bool naoChegouNoFinal(FILE* stream){
	return !feof(stream);
}
----

Escolhemos ler o fluxo de entrada por linhas, o código a seguir
implementa esta funcionalidade:

[source,c]
----
int TAMANHO_MAXIMO_DA_LINHA = 2048; <1>
char* lerLinhaDaEntrada(FILE* entrada){
	char* linha = calloc(1, TAMANHO_MAXIMO_DA_LINHA); <2>
	return fgets(linha, TAMANHO_MAXIMO_DA_LINHA, entrada); <3>
}
----
<1> Definindo tamanho da linha (buffer).
<2> Alocando espaço suficiente para caber uma linha.
<3> Lendo da entrada e salvando o conteúdo lido no buffer (linha).

Para compreender esta função é preciso entender que <<fgets>> irá ler
até encontrar o fim de linha, ou até chegar ao final do fluxo ou até
ler a quantidade de caracteres referenciada por
`TAMANHO_MAXIMO_DA_LINHA`.

A primeira pergunta que pode surgir seria: ``E se a linha for maior do
que este tamanho máximo?'' Vamos supor que o tamanho máximo fosse 10
caracteres, e a linha tivesse 15 caracteres. Na primeira chamada a
este método seriam lidos os 10 primeiro caracteres, traduzidos e
processados. A próxima chamada iria ler os caracteres restante até o
final da linha. 

Finalmente, precisamos salvar o conteúdo traduzido na saída:

[source,c]
.Escrevendo conteúdo na saída
----
void salvaConteudoNaSaida(char* conteudo, FILE* saida){
	int tamanhoDaMensagem = strlen(conteudo);
	fwrite(conteudo,1,tamanhoDaMensagem,saida);
}
----

==== Verificando que teste continua passando

Após estas atualizações, vamos verificar se nossos testes continuam
passando:

.Verificando os testes passando após as modificações
....
$ make clean && make lingua-do-i-test && make test_all 
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
./lingua-do-i-test
....

==== Atualizando aplicação para processar fluxos

Após os testes passarem, nosso próximo passo será a atualização da
aplicação para utilizar a nova implementação:

[source,c]
.Atualizando main para processar fluxos
----
int main(int argc, const char* argv[]) {
	FILE* entrada = determinaEntrada(argc, argv);
	if (entrada){
		traduzFluxoDeEntradaNaSaida(entrada, stdout);
	}else{
		fprintf(stderr, "Problema ao abrir arquivo: %s\n",
				argv[1]);
		exit(EXIT_FAILURE);
	}
	return EXIT_SUCCESS;
}
----

.Compilando a aplicação
....
$ make clean && make lingua-do-i
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i.c lingua-do-i-core.c -o lingua-do-i
....

Verificando aplicação processando entrada por fluxo:

.Utilizando aplicação para traduzir fluxo
....
$ cat musica-trecho.txt | ./lingua-do-i
Ih! Diis, pirdii isti pibri ciitidi
....

Ótimo! Nossa aplicação agora é capaz de processar o fluxo de entrada
também.

==== Código da etapa

Você pode consultar o código final desta etapa nos seguintes
arquivos:

.Código fonte
{online}/{etapa}/src/lingua-do-i.c[{local}/{etapa}/src/lingua-do-i.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-test.c[{local}/{etapa}/src/lingua-do-i-test.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.c[{local}/{etapa}/src/lingua-do-i-core.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.h[{local}/{etapa}/src/lingua-do-i-core.h]

.Código fonte
{online}/{etapa}/src/musica-trecho.txt[{local}/{etapa}/src/musica-trecho.txt]

.Código fonte
{online}/{etapa}/src/Makefile[{local}/{etapa}/src/Makefile]


=== XXX
* Escrever uma função que seja responsável por ler o conteúdo de um
  arquivo e retornar o conteúdo lido como um string (`char *`).
* Esta função se chamará `lerConteudoDoArquivo` e terá como parâmetro
  o nome do arquivo que desejamos ler (`char* nomeDoArquivo`).
* Esta função será definida no arquivo de cabeçalho
  (`lingua-do-i-core.h`) e implementada no arquivo fonte
  (`lingua-do-i-core.c`).
* Para 


=== Exemplos e diferenças entre Arquivos e Streams

|====
| Exemplo | Tipo | Origem
| Documento do Word | Arquivo | Disco
| Música MP3 | Arquivo | Disco
| Música em rádio on-line | Stream | Placa de Rede
| Vídeo on-line | Stream | Placa de Rede
| Comandos de voz | Stream | Microfone
| Comandos de texto | Stream | Teclado
| Imagem JPG | Arquivo | Discofootnote:[Se a imagem teve origem numa
câmera, você provavelmente copiou a imagem do cartão de memória (que é
um disco).]
| Vídeo de Segurança | Stream | Webcam
|====

Em C Arquivos e Streams (fluxos) são representados da mesma forma,
possuindo uma interface única para processar os dados. No entanto,
eles possuem características diferentes:

|====
| Recurso | Arquivo | Stream/Fluxo
| Podemos ler/escrever bytes/caracteres | Sim | Sim
| Sabemos o seu tamanho antecipadamente | Sim | Não
| São finitos | Sim | Não 
| Seu tamanho pode ser maior do que a RAM do computador | Sim | Sim
| Podemos retroceder ou avançar para ler outra parte | Sim | Não
| A leitura/escrita podem ser realizadas por partes | Sim | Sim
| Origem mais comum | Disco | Dispositivos
|====

=== Pensando sobre a implementação da Língua do i

Vamos pensar um pouco no nosso programa que irá codificar um texto na
Língua do i. 

Qual será a fonte a dados que o programa irá processar?

* Teclado?
* Arquivo pre-fixado como `portugues.txt`?
* Qualquer arquivo solicitado pelo usuário?

[NOTE]
====
A leitura através do *teclado* geralmente consiste em escrever uma
mensagem na tela solicitando o usuário digitar o texto e em seguida
ler o que foi digitado e processar. 

* Digitar um texto grande pode ser tedioso. 
* Como interajo com o programa para informar que ele deve ser finalizado?
  Quando eu digitar a palavra 'Sair' numa linha vazia? Quando não
  digitar nada numa linha vazia?

A leitura através de um *arquivo pré-fixado* pode ser mais simples de
ser implementado, pois provavelmente não há tratamento de configuração
para descobrir qual o arquivo. No entanto, é chato ter sempre que
atualizar um arquivo único para funcionar.

A leitura de qualquer arquivo pode facilitar caso o usuário possua
vários arquivos com conteúdos longos que precisam ser traduzidos.
Provavelmente iremos precisar tratar qual o arquivo será utilizado no
processamento.
====

Como a entrada será processada?

* Ler o conteúdo inteiro e depois processa?
* Ler uma linha por vês e processa?
* Ler um carácter por vez e processa?

[NOTE]
====
Ler o conteúdo inteiro geralmente parece ser a opção mais fácil quando
estamos processando arquivos. No entanto, esta solução pode
inviabilizar o processamento quando a entrada for um fluxo sem fim, ou
até mesmo quando o conteúdo for maior do que a memória do computador.

Ler uma linha por vez pode ser uma solução fácil de implementar, pois
os arquivos de texto são naturalmente divididos em linhas.

Como a tradução para a Língua do i pode ser realizada um carácter por
vez, ela solução também parece viável.
====

Aonde o resultado será apresentado?

* Na tela?
* Em um arquivo fixo como `texto-na-lingua-do-i.txt`?
* Em qualquer arquivo configurado pelo usuário?

[NOTE]
====
A apresentação na tela pode ser uma solução viável caso os conteúdos
a serem traduzidos sejam possuam poucas linhas, caso contrário é
melhor salvar o resultado num arquivo.

Salvar o resultado em um arquivo fixo geralmente não é uma boa
solução, pois não poderíamos processar dois arquivos ao mesmo tempo,
correndo o risco do resultado de um processamento ser sobrescrito pelo
outro.
====

Aonde as mensagens de erros serão apresentadas?

* Na tela?
* Em um arquivo fixo como `erros.txt`?


[NOTE]
====
A primeira vista apresentar os erros na tela parece ser uma boa
solução, no entanto, caso o seu programa esteja rodando em um serviço
num servidor as vezes é mais fácil acessar um arquivo contendo os
erros, pois a ``tela'' do processo talvez esteja indisponível.
====

=== Entrada padrão, saída padrão e saída de erros

Todo programa em C possui automaticamente definido um arquivo para a
entrada padrão, um arquivo para a saída padrão e outro arquivo para
onde a emissão de mensages de erro será direcionada.

Quando vamos executar um programa podemos redirecionar a entrada e as
saídas para outros lugares, no entanto, se não houve nenhuma
configuração o sistema operacional irá configurá-las da seguinte
forma:

.Configuração padrão para as saídas e entradas
|====
| Entrada Padrão | Teclado
| Saída Padrão | Tela
| Saída de Erros | Tela
|====

(((Redirecionar, Entrada Padrão)))

Para redirecinar a Entrada Padrão para um arquivo qualquer basta
executar o programa informando o nome do arquivo da seguinte forma:

 meu-programa < nome-do-arquivo-de-entrada

Para testar a mudança da entrada padrão recomendo a utilização do
aplicativo `sort` (disponível no Linux, OSx e Windows), que realiza
ordenação a partir da entrada padrão.

.caminho do arquivo frutas
....
include::code/cap5/frutas.txt[]
....

 sort < frutas.txt

.Resultado da execução do comando
....
include::code/cap5/frutas-ordenadas.txt[]
....

Além de redirecionar a entrada, nós também podemos redirecionar a
saída para um arquivo da seguinte forma:

 sort < frutas.txt > frutas-ordenadas.txt

Desta forma, o arquivo `frutas-ordenadas.txt` será criado
contendo o mesmo resultado da execução anterior. 

Para demonstrar o redirecionamento da saída de erro vamos utilizar o
comando `mkdir` para tentar criar um diretório que já existe.

 mkdir meudir
 mkdir meudir
 mkdir meudir 2> erros.txt

Na primeira invocação do mkdir o diretório `meu-dir` será criado. Na
segunda invocação, você verá na tela a mensagem de erro relativo a
impossibilidade de criar um diretório que já existe. Na última
execução, as mensagens de erros serão redirecionadas para um arquivo
`erros.txt` que será criado após a execução.

IMPORTANT: Quando os programas vão escrever mensagens devem escolher
cuidadosamente quais as saídas utilizar.

TIP: Para conhecer um pouco mais sobre redirecionamentos consulte:
http://edusantana.github.io/dev/redirecionamentos.html.

=== Decisões sobre a implementação: entrada e saída 

O nosso aplicativo irá *ler o texto da entrada padrão e escrever a
mensagem traduzida na saída padrão*. Caso o usuário deseja traduzir um
arquivo bastará executar a aplicação passando o arquivo pela entrada
padrão. De forma similar, também podemos redirecionar o resultado para
um arquivo se desejar-mos.

.Questões em aberto
* Como a entrada será processada?
** Ler o conteúdo inteiro e depois processa?
** Ler uma linha por vês e processa?
** Ler um carácter por vez e processa?

Para aprender todas as formas de processar a entrada vamos implementar
todas as opções.

=== Lendo o conteúdo inteiro
Ler o conteúdo inteiro antes de processar poderá causa erro de
execução caso o arquivo de entrada seja grande demais.

Durante a implementação precisaremos consultar o tamanho total do
arquivo para poder alocar espaço suficiente para o arquivo. Em
seguida, iremos criar um string contendo todos os caracteres do texto.

Com o string em memória, poderemos processar os caracteres na ordem
que aparecem e trocar as vogais por `i`, imprimindo juntamente os
caracteres restantes que não forem vogais no saída padrão.

=== Lendo uma linha por vez
Para ler uma linha por vez precisamos alocar um espaço suficiente para
salvar uma linha, em seguida preenchê-lo com os caracteres lidos até
encontrar o carácter final de linha, representado por `\n`.

NOTE: Não há problemas em alocar espaço maior do que for utilizado,
contanto que o espaço restante seja inicializado com `\0`, pois a
primeira ocorrência indicará o final de um string, o restante será
ignorado.

=== Lendo um carácter por vez
Ler um carácter por vez não envolve necessidade de alocar espaço na
memória para leitura dos dados.

NOTE: Talvez teremos problemas com codificação do arquivo. Pois
caracteres especiais ocupam mais de um byte quando codificados em
*UTF-8* por exemplo. 


////
Terminando arquivo com linha em branco
////

